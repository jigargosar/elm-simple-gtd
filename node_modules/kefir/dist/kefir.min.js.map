{"version":3,"file":null,"sources":["/Users/anon/projects/my/kefir/src/utils/objects.js","/Users/anon/projects/my/kefir/src/utils/collections.js","/Users/anon/projects/my/kefir/src/dispatcher.js","/Users/anon/projects/my/kefir/src/observable.js","/Users/anon/projects/my/kefir/src/stream.js","/Users/anon/projects/my/kefir/src/property.js","/Users/anon/projects/my/kefir/src/primary/never.js","/Users/anon/projects/my/kefir/src/patterns/time-based.js","/Users/anon/projects/my/kefir/src/time-based/later.js","/Users/anon/projects/my/kefir/src/time-based/interval.js","/Users/anon/projects/my/kefir/src/time-based/sequentially.js","/Users/anon/projects/my/kefir/src/time-based/from-poll.js","/Users/anon/projects/my/kefir/src/emitter.js","/Users/anon/projects/my/kefir/src/time-based/with-interval.js","/Users/anon/projects/my/kefir/src/primary/stream.js","/Users/anon/projects/my/kefir/src/primary/from-callback.js","/Users/anon/projects/my/kefir/src/primary/from-node-callback.js","/Users/anon/projects/my/kefir/src/utils/functions.js","/Users/anon/projects/my/kefir/src/primary/from-sub-unsub.js","/Users/anon/projects/my/kefir/src/primary/from-events.js","/Users/anon/projects/my/kefir/src/primary/constant.js","/Users/anon/projects/my/kefir/src/primary/constant-error.js","/Users/anon/projects/my/kefir/src/patterns/one-source.js","/Users/anon/projects/my/kefir/src/one-source/to-property.js","/Users/anon/projects/my/kefir/src/one-source/changes.js","/Users/anon/projects/my/kefir/src/interop/from-promise.js","/Users/anon/projects/my/kefir/src/interop/to-promise.js","/Users/anon/projects/my/kefir/src/interop/from-es-observable.js","/Users/anon/projects/my/kefir/src/interop/to-es-observable.js","/Users/anon/projects/my/kefir/src/many-sources/combine.js","/Users/anon/projects/my/kefir/src/one-source/map.js","/Users/anon/projects/my/kefir/src/one-source/filter.js","/Users/anon/projects/my/kefir/src/one-source/take.js","/Users/anon/projects/my/kefir/src/one-source/take-errors.js","/Users/anon/projects/my/kefir/src/one-source/take-while.js","/Users/anon/projects/my/kefir/src/one-source/last.js","/Users/anon/projects/my/kefir/src/one-source/skip.js","/Users/anon/projects/my/kefir/src/one-source/skip-while.js","/Users/anon/projects/my/kefir/src/one-source/skip-duplicates.js","/Users/anon/projects/my/kefir/src/one-source/diff.js","/Users/anon/projects/my/kefir/src/one-source/scan.js","/Users/anon/projects/my/kefir/src/one-source/flatten.js","/Users/anon/projects/my/kefir/src/one-source/delay.js","/Users/anon/projects/my/kefir/src/one-source/throttle.js","/Users/anon/projects/my/kefir/src/one-source/debounce.js","/Users/anon/projects/my/kefir/src/one-source/map-errors.js","/Users/anon/projects/my/kefir/src/one-source/filter-errors.js","/Users/anon/projects/my/kefir/src/one-source/ignore-values.js","/Users/anon/projects/my/kefir/src/one-source/ignore-errors.js","/Users/anon/projects/my/kefir/src/one-source/ignore-end.js","/Users/anon/projects/my/kefir/src/one-source/before-end.js","/Users/anon/projects/my/kefir/src/one-source/sliding-window.js","/Users/anon/projects/my/kefir/src/one-source/buffer-while.js","/Users/anon/projects/my/kefir/src/one-source/buffer-with-count.js","/Users/anon/projects/my/kefir/src/one-source/buffer-with-time-or-count.js","/Users/anon/projects/my/kefir/src/one-source/transduce.js","/Users/anon/projects/my/kefir/src/one-source/with-handler.js","/Users/anon/projects/my/kefir/src/many-sources/zip.js","/Users/anon/projects/my/kefir/src/many-sources/abstract-pool.js","/Users/anon/projects/my/kefir/src/many-sources/merge.js","/Users/anon/projects/my/kefir/src/many-sources/repeat.js","/Users/anon/projects/my/kefir/src/many-sources/concat.js","/Users/anon/projects/my/kefir/src/many-sources/pool.js","/Users/anon/projects/my/kefir/src/many-sources/flat-map.js","/Users/anon/projects/my/kefir/src/many-sources/flat-map-errors.js","/Users/anon/projects/my/kefir/src/patterns/two-sources.js","/Users/anon/projects/my/kefir/src/two-sources/filter-by.js","/Users/anon/projects/my/kefir/src/two-sources/sampled-by.js","/Users/anon/projects/my/kefir/src/two-sources/skip-until-by.js","/Users/anon/projects/my/kefir/src/two-sources/take-until-by.js","/Users/anon/projects/my/kefir/src/two-sources/buffer-by.js","/Users/anon/projects/my/kefir/src/two-sources/buffer-while-by.js","/Users/anon/projects/my/kefir/src/two-sources/awaiting.js","/Users/anon/projects/my/kefir/src/one-source/values-to-errors.js","/Users/anon/projects/my/kefir/src/one-source/errors-to-values.js","/Users/anon/projects/my/kefir/src/one-source/end-on-error.js","/Users/anon/projects/my/kefir/src/index.js","/Users/anon/projects/my/kefir/src/constants.js","/Users/anon/projects/my/kefir/node_modules/symbol-observable/lib/ponyfill.js","/Users/anon/projects/my/kefir/node_modules/symbol-observable/lib/index.js","/Users/anon/projects/my/kefir/node_modules/symbol-observable/index.js","/Users/anon/projects/my/kefir/src/interop/static-land.js","/Users/anon/projects/my/kefir/src/utils/now.js"],"sourcesContent":["function createObj(proto) {\n  let F = function() {};\n  F.prototype = proto;\n  return new F();\n}\n\nfunction extend(target /*, mixin1, mixin2...*/) {\n  let length = arguments.length\n    , i, prop;\n  for (i = 1; i < length; i++) {\n    for (prop in arguments[i]) {\n      target[prop] = arguments[i][prop];\n    }\n  }\n  return target;\n}\n\nfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n  let length = arguments.length\n    , i;\n  Child.prototype = createObj(Parent.prototype);\n  Child.prototype.constructor = Child;\n  for (i = 2; i < length; i++) {\n    extend(Child.prototype, arguments[i]);\n  }\n  return Child;\n}\n\nexport {extend, inherit};\n","function concat(a, b) {\n  let result, length, i, j;\n  if (a.length === 0) {\n    return b;\n  }\n  if (b.length === 0) {\n    return a;\n  }\n  j = 0;\n  result = new Array(a.length + b.length);\n  length = a.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = a[i];\n  }\n  length = b.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = b[i];\n  }\n  return result;\n}\n\nfunction circleShift(arr, distance) {\n  let length = arr.length\n    , result = new Array(length)\n    , i;\n  for (i = 0; i < length; i++) {\n    result[(i + distance) % length] = arr[i];\n  }\n  return result;\n}\n\nfunction find(arr, value) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    if (arr[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction findByPred(arr, pred) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction cloneArray(input) {\n  let length = input.length\n    , result = new Array(length)\n    , i;\n  for (i = 0; i < length; i++) {\n    result[i] = input[i];\n  }\n  return result;\n}\n\nfunction remove(input, index) {\n  let length = input.length\n    , result, i, j;\n  if (index >= 0 && index < length) {\n    if (length === 1) {\n      return [];\n    } else {\n      result = new Array(length - 1);\n      for (i = 0, j = 0; i < length; i++) {\n        if (i !== index) {\n          result[j] = input[i];\n          j++;\n        }\n      }\n      return result;\n    }\n  } else {\n    return input;\n  }\n}\n\nfunction removeByPred(input, pred) {\n  return remove(input, findByPred(input, pred));\n}\n\nfunction map(input, fn) {\n  let length = input.length\n    , result = new Array(length)\n    , i;\n  for (i = 0; i < length; i++) {\n    result[i] = fn(input[i]);\n  }\n  return result;\n}\n\nfunction forEach(arr, fn) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    fn(arr[i]);\n  }\n}\n\nfunction fillArray(arr, value) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    arr[i] = value;\n  }\n}\n\nfunction contains(arr, value) {\n  return find(arr, value) !== -1;\n}\n\nfunction slide(cur, next, max) {\n  let length = Math.min(max, cur.length + 1),\n      offset = cur.length - length + 1,\n      result = new Array(length),\n      i;\n  for (i = offset; i < length; i++) {\n    result[i - offset] = cur[i];\n  }\n  result[length - 1] = next;\n  return result;\n}\n\n\n\n\nexport {\n  concat,\n  circleShift,\n  find,\n  findByPred,\n  cloneArray,\n  remove,\n  removeByPred,\n  map,\n  forEach,\n  fillArray,\n  contains,\n  slide\n};\n","import {extend} from './utils/objects';\nimport {VALUE, ERROR, ANY} from './constants';\nimport {concat, findByPred, remove, contains} from './utils/collections';\n\nfunction callSubscriber(type, fn, event) {\n  if (type === ANY) {\n    fn(event);\n  } else if (type === event.type) {\n    if (type === VALUE || type === ERROR) {\n      fn(event.value);\n    } else {\n      fn();\n    }\n  }\n}\n\nfunction Dispatcher() {\n  this._items = [];\n  this._spies = [];\n  this._inLoop = 0;\n  this._removedItems = null;\n}\n\nextend(Dispatcher.prototype, {\n\n  add(type, fn) {\n    this._items = concat(this._items, [{type, fn}]);\n    return this._items.length;\n  },\n\n  remove(type, fn) {\n    const index = findByPred(this._items, (x) => x.type === type && x.fn === fn);\n\n    // if we're currently in a notification loop,\n    // remember this subscriber was removed\n    if (this._inLoop !== 0 && index !== -1) {\n      if (this._removedItems === null) {\n        this._removedItems = [];\n      }\n      this._removedItems.push(this._items[index]);\n    }\n\n    this._items = remove(this._items, index);\n    return this._items.length;\n  },\n\n\n  addSpy(fn) {\n    this._spies = concat(this._spies, [fn]);\n    return this._spies.length;\n  },\n\n  // Because spies are only ever a function that perform logging as\n  // their only side effect, we don't need the same complicated\n  // removal logic like in remove()\n  removeSpy(fn) {\n    this._spies = remove(this._spies, this._spies.indexOf(fn));\n    return this._spies.length;\n  },\n\n  dispatch(event) {\n    this._inLoop++;\n    for (let i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n      spies[i](event);\n    }\n\n    for (let i = 0, items = this._items; i < items.length; i++) {\n\n      // cleanup was called\n      if (this._items === null) {\n        break;\n      }\n\n      // this subscriber was removed\n      if (this._removedItems !== null && contains(this._removedItems, items[i])) {\n        continue;\n      }\n\n      callSubscriber(items[i].type, items[i].fn, event);\n    }\n    this._inLoop--;\n    if (this._inLoop === 0) {\n      this._removedItems = null;\n    }\n  },\n\n  cleanup() {\n    this._items = null;\n    this._spies = null;\n  }\n\n});\n\n\nexport {callSubscriber, Dispatcher};\n","import {extend} from './utils/objects';\nimport {VALUE, ERROR, ANY, END} from './constants';\nimport {Dispatcher, callSubscriber} from './dispatcher';\nimport {findByPred} from './utils/collections';\n\n\n\nfunction Observable() {\n  this._dispatcher = new Dispatcher();\n  this._active = false;\n  this._alive = true;\n  this._activating = false;\n  this._logHandlers = null;\n  this._spyHandlers = null;\n}\n\nextend(Observable.prototype, {\n\n  _name: 'observable',\n\n  _onActivation() {},\n  _onDeactivation() {},\n\n  _setActive(active) {\n    if (this._active !== active) {\n      this._active = active;\n      if (active) {\n        this._activating = true;\n        this._onActivation();\n        this._activating = false;\n      } else {\n        this._onDeactivation();\n      }\n    }\n  },\n\n  _clear() {\n    this._setActive(false);\n    this._dispatcher.cleanup();\n    this._dispatcher = null;\n    this._logHandlers = null;\n  },\n\n  _emit(type, x) {\n    switch (type) {\n      case VALUE: return this._emitValue(x);\n      case ERROR: return this._emitError(x);\n      case END: return this._emitEnd();\n    }\n  },\n\n  _emitValue(value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({type: VALUE, value});\n    }\n  },\n\n  _emitError(value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({type: ERROR, value});\n    }\n  },\n\n  _emitEnd() {\n    if (this._alive) {\n      this._alive = false\n      this._dispatcher.dispatch({type: END});\n      this._clear();\n    }\n  },\n\n  _on(type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    } else {\n      callSubscriber(type, fn, {type: END});\n    }\n    return this;\n  },\n\n  _off(type, fn) {\n    if (this._alive) {\n      let count = this._dispatcher.remove(type, fn);\n      if (count === 0) {\n        this._setActive(false);\n      }\n    }\n    return this;\n  },\n\n  onValue(fn) {\n    return this._on(VALUE, fn);\n  },\n  onError(fn) {\n    return this._on(ERROR, fn);\n  },\n  onEnd(fn) {\n    return this._on(END, fn);\n  },\n  onAny(fn) {\n    return this._on(ANY, fn);\n  },\n\n  offValue(fn) {\n    return this._off(VALUE, fn);\n  },\n  offError(fn) {\n    return this._off(ERROR, fn);\n  },\n  offEnd(fn) {\n    return this._off(END, fn);\n  },\n  offAny(fn) {\n    return this._off(ANY, fn);\n  },\n\n  observe(observerOrOnValue, onError, onEnd) {\n    const _this = this;\n    let closed = false;\n\n    const observer = !observerOrOnValue || typeof observerOrOnValue === 'function'\n      ? {value: observerOrOnValue, error: onError, end: onEnd}\n      : observerOrOnValue;\n\n    const handler = function(event) {\n      if (event.type === END) {\n        closed = true;\n      }\n      if (event.type === VALUE && observer.value) {\n        observer.value(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.end) {\n        observer.end(event.value);\n      }\n    };\n\n    this.onAny(handler);\n\n    return {\n      unsubscribe() {\n        if (!closed) {\n          _this.offAny(handler);\n          closed = true;\n        }\n      },\n      get closed() {\n        return closed;\n      }\n    };\n  },\n\n  // A and B must be subclasses of Stream and Property (order doesn't matter)\n  _ofSameType(A, B) {\n    return A.prototype.getType() === this.getType() ? A : B;\n  },\n\n  setName(sourceObs /* optional */, selfName) {\n    this._name = selfName ? `${sourceObs._name}.${selfName}` : sourceObs;\n    return this;\n  },\n\n\n  log(name = this.toString()) {\n\n    let isCurrent\n    let handler = function(event) {\n      let type = `<${event.type}${isCurrent ? ':current' : ''}>`;\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n\n    if (this._alive) {\n      if (!this._logHandlers) {\n        this._logHandlers = [];\n      }\n      this._logHandlers.push({name: name, handler: handler});\n    }\n\n    isCurrent = true;\n    this.onAny(handler);\n    isCurrent = false;\n\n    return this;\n  },\n\n  offLog(name = this.toString()) {\n\n    if (this._logHandlers) {\n      let handlerIndex = findByPred(this._logHandlers, obj => obj.name === name);\n      if (handlerIndex !== -1) {\n        this.offAny(this._logHandlers[handlerIndex].handler);\n        this._logHandlers.splice(handlerIndex, 1);\n      }\n    }\n\n    return this;\n  },\n\n  spy(name = this.toString()) {\n    let handler = function(event) {\n      let type = `<${event.type}>`;\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n    if (this._alive) {\n      if (!this._spyHandlers) {\n        this._spyHandlers = [];\n      }\n      this._spyHandlers.push({name: name, handler: handler});\n      this._dispatcher.addSpy(handler);\n    }\n    return this;\n  },\n\n  offSpy(name = this.toString()) {\n    if (this._spyHandlers) {\n      let handlerIndex = findByPred(this._spyHandlers, obj => obj.name === name);\n      if (handlerIndex !== -1) {\n        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n        this._spyHandlers.splice(handlerIndex, 1);\n      }\n    }\n    return this;\n  }\n});\n\n// extend() can't handle `toString` in IE8\nObservable.prototype.toString = function() {\n  return `[${this._name}]`;\n};\n\n\nexport default Observable;\n","import {inherit} from './utils/objects';\nimport Observable from './observable';\n\n\nfunction Stream() {\n  Observable.call(this);\n}\n\ninherit(Stream, Observable, {\n\n  _name: 'stream',\n\n  getType() {\n    return 'stream';\n  }\n\n});\n\nexport default Stream;\n","import {inherit} from './utils/objects';\nimport {VALUE, ERROR, END} from './constants';\nimport {callSubscriber} from './dispatcher';\nimport Observable from './observable';\n\n\n\nfunction Property() {\n  Observable.call(this);\n  this._currentEvent = null;\n}\n\ninherit(Property, Observable, {\n\n  _name: 'property',\n\n  _emitValue(value) {\n    if (this._alive) {\n      this._currentEvent = {type: VALUE, value};\n      if (!this._activating) {\n        this._dispatcher.dispatch({type: VALUE, value});\n      }\n    }\n  },\n\n  _emitError(value) {\n    if (this._alive) {\n      this._currentEvent = {type: ERROR, value};\n      if (!this._activating) {\n        this._dispatcher.dispatch({type: ERROR, value});\n      }\n    }\n  },\n\n  _emitEnd() {\n    if (this._alive) {\n      this._alive = false\n      if (!this._activating) {\n        this._dispatcher.dispatch({type: END});\n      }\n      this._clear();\n    }\n  },\n\n\n  _on(type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    }\n    if (this._currentEvent !== null) {\n      callSubscriber(type, fn, this._currentEvent);\n    }\n    if (!this._alive) {\n      callSubscriber(type, fn, {type: END});\n    }\n    return this;\n  },\n\n  getType() {\n    return 'property';\n  }\n\n});\n\nexport default Property;\n\n\n\n\n\n\n","import Stream from '../stream';\n\n\nconst neverS = new Stream();\nneverS._emitEnd();\nneverS._name = 'never';\n\nexport default function never() {\n  return neverS;\n}\n","import {inherit} from '../utils/objects';\nimport Stream from '../stream';\n\nexport default function timeBased(mixin) {\n\n  function AnonymousStream(wait, options) {\n    Stream.call(this);\n    this._wait = wait;\n    this._intervalId = null;\n    this._$onTick = () => this._onTick();\n    this._init(options);\n  }\n\n  inherit(AnonymousStream, Stream, {\n\n    _init() {},\n    _free() {},\n\n    _onTick() {},\n\n    _onActivation() {\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    },\n\n    _onDeactivation() {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n    },\n\n    _clear() {\n      Stream.prototype._clear.call(this);\n      this._$onTick = null;\n      this._free();\n    }\n\n  }, mixin);\n\n  return AnonymousStream;\n}\n","import timeBased from '../patterns/time-based';\n\nconst S = timeBased({\n\n  _name: 'later',\n\n  _init({x}) {\n    this._x = x;\n  },\n\n  _free() {\n    this._x = null;\n  },\n\n  _onTick() {\n    this._emitValue(this._x);\n    this._emitEnd();\n  }\n\n});\n\n\nexport default function later(wait, x) {\n  return new S(wait, {x});\n}\n","import timeBased from '../patterns/time-based';\n\nconst S = timeBased({\n\n  _name: 'interval',\n\n  _init({x}) {\n    this._x = x;\n  },\n\n  _free() {\n    this._x = null;\n  },\n\n  _onTick() {\n    this._emitValue(this._x);\n  }\n\n});\n\n\nexport default function interval(wait, x) {\n  return new S(wait, {x});\n}\n","import timeBased from '../patterns/time-based';\nimport {cloneArray} from '../utils/collections';\nimport never from '../primary/never';\n\nconst S = timeBased({\n\n  _name: 'sequentially',\n\n  _init({xs}) {\n    this._xs = cloneArray(xs);\n  },\n\n  _free() {\n    this._xs = null;\n  },\n\n  _onTick() {\n    if (this._xs.length === 1) {\n      this._emitValue(this._xs[0]);\n      this._emitEnd();\n    } else {\n      this._emitValue(this._xs.shift());\n    }\n  }\n\n});\n\n\nexport default function sequentially(wait, xs) {\n  return xs.length === 0 ? never() : new S(wait, {xs});\n}\n","import timeBased from '../patterns/time-based';\n\nconst S = timeBased({\n\n  _name: 'fromPoll',\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _onTick() {\n    const fn = this._fn;\n    this._emitValue(fn());\n  }\n\n});\n\n\nexport default function fromPoll(wait, fn) {\n  return new S(wait, {fn});\n}\n","export default function emitter(obs) {\n\n  function value(x) {\n    obs._emitValue(x);\n    return obs._active;\n  }\n\n  function error(x) {\n    obs._emitError(x);\n    return obs._active;\n  }\n\n  function end() {\n    obs._emitEnd();\n    return obs._active;\n  }\n\n  function event(e) {\n    obs._emit(e.type, e.value);\n    return obs._active;\n  }\n\n  return {\n    value,\n    error,\n    end,\n    event,\n\n    // legacy\n    emit: value,\n    emitEvent: event\n  };\n}\n","import timeBased from '../patterns/time-based';\nimport emitter from '../emitter';\n\n\nconst S = timeBased({\n\n  _name: 'withInterval',\n\n  _init({fn}) {\n    this._fn = fn;\n    this._emitter = emitter(this);\n  },\n\n  _free() {\n    this._fn = null;\n    this._emitter = null;\n  },\n\n  _onTick() {\n    const fn = this._fn;\n    fn(this._emitter);\n  }\n\n});\n\n\nexport default function withInterval(wait, fn) {\n  return new S(wait, {fn});\n}\n","import {inherit} from '../utils/objects';\nimport Stream from '../stream';\nimport emitter from '../emitter';\n\nfunction S(fn) {\n  Stream.call(this);\n  this._fn = fn;\n  this._unsubscribe = null;\n}\n\ninherit(S, Stream, {\n\n  _name: 'stream',\n\n  _onActivation() {\n    const fn = this._fn;\n    const unsubscribe = fn(emitter(this));\n    this._unsubscribe = (typeof unsubscribe === 'function') ? unsubscribe : null;\n\n    // fix https://github.com/rpominov/kefir/issues/35\n    if (!this._active) {\n      this._callUnsubscribe();\n    }\n  },\n\n  _callUnsubscribe() {\n    if (this._unsubscribe !== null) {\n      this._unsubscribe();\n      this._unsubscribe = null;\n    }\n  },\n\n  _onDeactivation() {\n    this._callUnsubscribe();\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._fn = null;\n  }\n\n});\n\nexport default function stream(fn) {\n  return new S(fn);\n}\n","import stream from './stream';\n\nexport default function fromCallback(callbackConsumer) {\n\n  let called = false;\n\n  return stream(function(emitter) {\n\n    if (!called) {\n      callbackConsumer(function(x) {\n        emitter.emit(x);\n        emitter.end();\n      });\n      called = true;\n    }\n\n  }).setName('fromCallback');\n}\n","import stream from './stream';\n\nexport default function fromNodeCallback(callbackConsumer) {\n\n  let called = false;\n\n  return stream(function(emitter) {\n\n    if (!called) {\n      callbackConsumer(function(error, x) {\n        if (error) {\n          emitter.error(error);\n        } else {\n          emitter.emit(x);\n        }\n        emitter.end();\n      });\n      called = true;\n    }\n\n  }).setName('fromNodeCallback');\n\n}\n","function spread(fn, length) {\n  switch(length) {\n    case 0: return function() {return fn();};\n    case 1: return function(a) {return fn(a[0]);};\n    case 2: return function(a) {return fn(a[0], a[1]);};\n    case 3: return function(a) {return fn(a[0], a[1], a[2]);};\n    case 4: return function(a) {return fn(a[0], a[1], a[2], a[3]);};\n    default: return function(a) {return fn.apply(null, a);};\n  }\n}\n\nfunction apply(fn, c, a) {\n  let aLength = a ? a.length : 0;\n  if (c == null) {\n    switch (aLength) {\n      case 0: return fn();\n      case 1: return fn(a[0]);\n      case 2: return fn(a[0], a[1]);\n      case 3: return fn(a[0], a[1], a[2]);\n      case 4: return fn(a[0], a[1], a[2], a[3]);\n      default: return fn.apply(null, a);\n    }\n  } else {\n    switch (aLength) {\n      case 0: return fn.call(c);\n      default: return fn.apply(c, a);\n    }\n  }\n}\n\nexport {spread, apply};\n","import stream from './stream';\nimport {apply} from '../utils/functions';\n\nexport default function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n  return stream(function(emitter) {\n\n    let handler = transformer\n      ? function() {\n        emitter.emit(apply(transformer, this, arguments));\n      }\n      : x => {\n        emitter.emit(x)\n      };\n\n    sub(handler);\n    return () => unsub(handler);\n\n  }).setName('fromSubUnsub');\n}\n","import fromSubUnsub from './from-sub-unsub';\n\nconst pairs = [\n  ['addEventListener', 'removeEventListener'],\n  ['addListener', 'removeListener'],\n  ['on', 'off']\n];\n\nexport default function fromEvents(target, eventName, transformer) {\n  let sub, unsub;\n\n  for (let i = 0; i < pairs.length; i++) {\n    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n      sub = pairs[i][0];\n      unsub = pairs[i][1];\n      break;\n    }\n  }\n\n  if (sub === undefined) {\n    throw new Error('target don\\'t support any of ' +\n      'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n  }\n\n  return fromSubUnsub(\n    (handler) => target[sub](eventName, handler),\n    (handler) => target[unsub](eventName, handler),\n    transformer\n  ).setName('fromEvents');\n}\n","import {inherit} from '../utils/objects';\nimport Property from '../property';\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P(value) {\n  this._currentEvent = {type: 'value', value, current: true};\n}\n\ninherit(P, Property, {\n  _name: 'constant',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nexport default function constant(x) {\n  return new P(x);\n}\n","import {inherit} from '../utils/objects';\nimport Property from '../property';\n\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P(value) {\n  this._currentEvent = {type: 'error', value, current: true};\n}\n\ninherit(P, Property, {\n  _name: 'constantError',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nexport default function constantError(x) {\n  return new P(x);\n}\n","import Stream from '../stream';\nimport Property from '../property';\nimport {inherit} from '../utils/objects';\nimport {VALUE, ERROR, END} from '../constants';\n\n\nfunction createConstructor(BaseClass, name) {\n  return function AnonymousObservable(source, options) {\n    BaseClass.call(this);\n    this._source = source;\n    this._name = `${source._name}.${name}`;\n    this._init(options);\n    this._$handleAny = (event) => this._handleAny(event);\n  }\n}\n\nfunction createClassMethods(BaseClass) {\n  return {\n\n    _init() {},\n    _free() {},\n\n    _handleValue(x) {\n      this._emitValue(x);\n    },\n    _handleError(x) {\n      this._emitError(x);\n    },\n    _handleEnd() {\n      this._emitEnd();\n    },\n\n    _handleAny(event) {\n      switch (event.type) {\n        case VALUE: return this._handleValue(event.value);\n        case ERROR: return this._handleError(event.value);\n        case END: return this._handleEnd();\n      }\n    },\n\n    _onActivation() {\n      this._source.onAny(this._$handleAny);\n    },\n    _onDeactivation() {\n      this._source.offAny(this._$handleAny);\n    },\n\n    _clear() {\n      BaseClass.prototype._clear.call(this);\n      this._source = null;\n      this._$handleAny = null;\n      this._free();\n    }\n\n  };\n}\n\n\n\nfunction createStream(name, mixin) {\n  const S = createConstructor(Stream, name);\n  inherit(S, Stream, createClassMethods(Stream), mixin);\n  return S;\n}\n\n\nfunction createProperty(name, mixin) {\n  const P = createConstructor(Property, name);\n  inherit(P, Property, createClassMethods(Property), mixin);\n  return P;\n}\n\n\nexport {createStream, createProperty};\n","import {createProperty} from '../patterns/one-source';\n\n\nconst P = createProperty('toProperty', {\n\n  _init({fn}) {\n    this._getInitialCurrent = fn;\n  },\n\n  _onActivation() {\n    if (this._getInitialCurrent !== null) {\n      const getInitial = this._getInitialCurrent;\n      this._emitValue(getInitial());\n    }\n    this._source.onAny(this._$handleAny);  // copied from patterns/one-source\n  }\n\n});\n\n\n\nexport default function toProperty(obs, fn = null) {\n  if (fn !== null && typeof fn !== 'function') {\n    throw new Error('You should call toProperty() with a function or no arguments.');\n  }\n  return new P(obs, {fn});\n}\n","import {createStream} from '../patterns/one-source';\n\n\n\nconst S = createStream('changes', {\n\n  _handleValue(x) {\n    if (!this._activating) {\n      this._emitValue(x);\n    }\n  },\n\n  _handleError(x) {\n    if (!this._activating) {\n      this._emitError(x);\n    }\n  }\n\n});\n\n\nexport default function changes(obs) {\n  return new S(obs);\n}\n","import stream from '../primary/stream';\nimport toProperty from '../one-source/to-property';\n\nexport default function fromPromise(promise) {\n\n  let called = false;\n\n  let result = stream(function(emitter) {\n    if (!called) {\n      let onValue = function(x) {\n        emitter.emit(x);\n        emitter.end();\n      };\n      let onError = function(x) {\n        emitter.error(x);\n        emitter.end();\n      };\n      let _promise = promise.then(onValue, onError);\n\n      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n      if (_promise && typeof _promise.done === 'function') {\n        _promise.done();\n      }\n\n      called = true;\n    }\n  })\n\n  return toProperty(result, null).setName('fromPromise');\n\n}\n","import {VALUE, END} from '../constants';\n\nfunction getGlodalPromise() {\n  if (typeof Promise === 'function') {\n    return Promise;\n  } else {\n    throw new Error('There isn\\'t default Promise, use shim or parameter');\n  }\n}\n\nexport default function(obs, Promise = getGlodalPromise()) {\n  let last = null;\n  return new Promise((resolve, reject) => {\n    obs.onAny(event => {\n      if (event.type === END && last !== null) {\n        (last.type === VALUE ? resolve : reject)(last.value);\n        last = null;\n      } else {\n        last = event;\n      }\n    });\n  });\n}\n","import stream from '../primary/stream';\nimport $$observable from 'symbol-observable';\n\nexport default function fromESObservable(_observable) {\n  const observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n  return stream(function(emitter) {\n    const unsub = observable.subscribe({\n      error(error) {\n        emitter.error(error);\n        emitter.end();\n      },\n      next(value) {\n        emitter.emit(value);\n      },\n      complete() {\n        emitter.end();\n      }\n    })\n\n    if (unsub.unsubscribe) {\n      return function () { unsub.unsubscribe(); };\n    } else {\n      return unsub;\n    }\n  }).setName('fromESObservable');\n}\n","import $$observable from 'symbol-observable';\nimport {extend} from '../utils/objects';\nimport {VALUE, ERROR, END} from '../constants';\n\nfunction ESObservable(observable) {\n  this._observable = observable.takeErrors(1);\n}\n\nextend(ESObservable.prototype, {\n  subscribe(observerOrOnNext, onError, onComplete) {\n\n    const observer = typeof observerOrOnNext === 'function'\n      ? {next: observerOrOnNext, error: onError, complete: onComplete}\n      : observerOrOnNext\n\n    const fn = event => {\n      if (event.type === END) {\n        closed = true;\n      }\n\n      if (event.type === VALUE && observer.next) {\n        observer.next(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.complete) {\n        observer.complete(event.value);\n      }\n    }\n\n    this._observable.onAny(fn);\n    let closed = false\n\n    const subscription = {\n      unsubscribe: () => {\n        closed = true;\n        this._observable.offAny(fn);\n      },\n      get closed() {\n        return closed\n      }\n    };\n    return subscription;\n\n  }\n});\n\n// Need to assign directly b/c Symbols aren't enumerable.\nESObservable.prototype[$$observable] = function() {\n  return this;\n};\n\nexport default function toESObservable() {\n  return new ESObservable(this);\n}\n","import Stream from '../stream';\nimport {VALUE, ERROR, NOTHING} from '../constants';\nimport {inherit} from '../utils/objects';\nimport {concat, fillArray} from '../utils/collections';\nimport {spread} from '../utils/functions';\nimport never from '../primary/never';\n\nfunction collect(source, keys, values) {\n  for (var prop in source) {\n    if( source.hasOwnProperty( prop ) ) {\n      keys.push(prop);\n      values.push(source[prop]);\n    }\n  }\n}\n\nfunction defaultErrorsCombinator(errors) {\n  let latestError;\n  for (let i = 0; i < errors.length; i++) {\n    if (errors[i] !== undefined) {\n      if (latestError === undefined || latestError.index < errors[i].index) {\n        latestError = errors[i];\n      }\n    }\n  }\n  return latestError.error;\n}\n\nfunction Combine(active, passive, combinator) {\n  Stream.call(this);\n  this._activeCount = active.length;\n  this._sources = concat(active, passive);\n  this._combinator = combinator;\n  this._aliveCount = 0;\n  this._latestValues = new Array(this._sources.length);\n  this._latestErrors = new Array(this._sources.length);\n  fillArray(this._latestValues, NOTHING);\n  this._emitAfterActivation = false;\n  this._endAfterActivation = false;\n  this._latestErrorIndex = 0;\n\n  this._$handlers = [];\n  for (let i = 0; i < this._sources.length; i++) {\n    this._$handlers.push((event) => this._handleAny(i, event));\n  }\n\n}\n\n\ninherit(Combine, Stream, {\n\n  _name: 'combine',\n\n  _onActivation() {\n    this._aliveCount = this._activeCount;\n\n    // we need to suscribe to _passive_ sources before _active_\n    // (see https://github.com/rpominov/kefir/issues/98)\n    for (let i = this._activeCount; i < this._sources.length; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n    for (let i = 0; i < this._activeCount; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n\n    if (this._emitAfterActivation) {\n      this._emitAfterActivation = false;\n      this._emitIfFull();\n    }\n    if (this._endAfterActivation) {\n      this._emitEnd();\n    }\n  },\n\n  _onDeactivation() {\n    let length = this._sources.length,\n        i;\n    for (i = 0; i < length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n\n  _emitIfFull() {\n    let hasAllValues = true;\n    let hasErrors = false;\n    let length = this._latestValues.length;\n    let valuesCopy = new Array(length);\n    let errorsCopy = new Array(length);\n\n    for (let i = 0; i < length; i++) {\n      valuesCopy[i] = this._latestValues[i];\n      errorsCopy[i] = this._latestErrors[i];\n\n      if (valuesCopy[i] === NOTHING) {\n        hasAllValues = false;\n      }\n\n      if (errorsCopy[i] !== undefined) {\n        hasErrors = true;\n      }\n    }\n\n    if (hasAllValues) {\n      const combinator = this._combinator;\n      this._emitValue(combinator(valuesCopy));\n    }\n    if (hasErrors) {\n      this._emitError(defaultErrorsCombinator(errorsCopy));\n    }\n  },\n\n  _handleAny(i, event) {\n\n    if (event.type === VALUE || event.type === ERROR) {\n\n      if (event.type === VALUE) {\n        this._latestValues[i] = event.value;\n        this._latestErrors[i] = undefined;\n      }\n      if (event.type === ERROR) {\n        this._latestValues[i] = NOTHING;\n        this._latestErrors[i] = {\n          index: this._latestErrorIndex++,\n          error: event.value\n        };\n      }\n\n      if (i < this._activeCount) {\n        if (this._activating) {\n          this._emitAfterActivation = true;\n        } else {\n          this._emitIfFull();\n        }\n      }\n\n    } else { // END\n\n      if (i < this._activeCount) {\n        this._aliveCount--;\n        if (this._aliveCount === 0) {\n          if (this._activating) {\n            this._endAfterActivation = true;\n          } else {\n            this._emitEnd();\n          }\n        }\n      }\n\n    }\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._latestValues = null;\n    this._latestErrors = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n\n});\n\nfunction combineAsArray(active, passive = [], combinator) {\n  if (!Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  combinator = combinator ? spread(combinator, active.length + passive.length) : (x => x);\n  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n}\n\nfunction combineAsObject(active, passive = {}, combinator) {\n  if (typeof passive !== 'object' || Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  let keys = [],\n    activeObservables = [],\n    passiveObservables = [];\n\n  collect(active, keys, activeObservables);\n  collect(passive, keys, passiveObservables);\n\n  const objectify = values => {\n    let event = {};\n    for(let i = values.length - 1; 0 <= i; i--) {\n      event[keys[i]] = values[i];\n    }\n    return combinator ? combinator(event) : event;\n  }\n\n  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n}\n\nexport default function combine(active, passive, combinator) {\n  if (typeof passive === 'function') {\n    combinator = passive;\n    passive = undefined;\n  }\n\n  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    this._emitValue(fn(x));\n  }\n\n};\n\nconst S = createStream('map', mixin);\nconst P = createProperty('map', mixin);\n\n\nconst id = x => x;\n\nexport default function map(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('filter', mixin);\nconst P = createProperty('filter', mixin);\n\n\nconst id = x => x;\n\nexport default function filter(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({n}) {\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n\n  _handleValue(x) {\n    this._n--;\n    this._emitValue(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('take', mixin);\nconst P = createProperty('take', mixin);\n\n\nexport default function take(obs, n) {\n  return new (obs._ofSameType(S, P))(obs, {n});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({n}) {\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n\n  _handleError(x) {\n    this._n--;\n    this._emitError(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('takeErrors', mixin);\nconst P = createProperty('takeErrors', mixin);\n\n\nexport default function takeErrors(obs, n) {\n  return new (obs._ofSameType(S, P))(obs, {n});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    } else {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('takeWhile', mixin);\nconst P = createProperty('takeWhile', mixin);\n\n\nconst id = x => x;\n\nexport default function takeWhile(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport {NOTHING} from '../constants';\n\nconst mixin = {\n\n  _init() {\n    this._lastValue = NOTHING;\n  },\n\n  _free() {\n    this._lastValue = null;\n  },\n\n  _handleValue(x) {\n    this._lastValue = x;\n  },\n\n  _handleEnd() {\n    if (this._lastValue !== NOTHING) {\n      this._emitValue(this._lastValue);\n    }\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('last', mixin);\nconst P = createProperty('last', mixin);\n\n\nexport default function last(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({n}) {\n    this._n = Math.max(0, n);\n  },\n\n  _handleValue(x) {\n    if (this._n === 0) {\n      this._emitValue(x);\n    } else {\n      this._n--;\n    }\n  }\n\n};\n\nconst S = createStream('skip', mixin);\nconst P = createProperty('skip', mixin);\n\n\nexport default function skip(obs, n) {\n  return new (obs._ofSameType(S, P))(obs, {n});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (this._fn !== null && !fn(x)) {\n      this._fn = null;\n    }\n    if (this._fn === null) {\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('skipWhile', mixin);\nconst P = createProperty('skipWhile', mixin);\n\n\nconst id = x => x;\n\nexport default function skipWhile(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport {NOTHING} from '../constants';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n    this._prev = NOTHING;\n  },\n\n  _free() {\n    this._fn = null;\n    this._prev = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (this._prev === NOTHING || !fn(this._prev, x)) {\n      this._prev = x;\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('skipDuplicates', mixin);\nconst P = createProperty('skipDuplicates', mixin);\n\n\nconst eq = (a, b) => a === b;\n\nexport default function skipDuplicates(obs, fn = eq) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport {NOTHING} from '../constants';\n\nconst mixin = {\n\n  _init({fn, seed}) {\n    this._fn = fn;\n    this._prev = seed;\n  },\n\n  _free() {\n    this._prev = null;\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    if (this._prev !== NOTHING) {\n      const fn = this._fn;\n      this._emitValue(fn(this._prev, x));\n    }\n    this._prev = x;\n  }\n\n};\n\nconst S = createStream('diff', mixin);\nconst P = createProperty('diff', mixin);\n\n\nfunction defaultFn(a, b) {\n  return [a, b];\n}\n\nexport default function diff(obs, fn, seed = NOTHING) {\n  return new (obs._ofSameType(S, P))(obs, {fn: fn || defaultFn, seed});\n}\n","import {createProperty} from '../patterns/one-source';\nimport {ERROR, NOTHING} from '../constants';\n\n\nconst P = createProperty('scan', {\n\n  _init({fn, seed}) {\n    this._fn = fn;\n    this._seed = seed;\n    if (seed !== NOTHING) {\n      this._emitValue(seed);\n    }\n  },\n\n  _free() {\n    this._fn = null;\n    this._seed = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n    } else {\n      this._emitValue(fn(this._currentEvent.value, x));\n    }\n  }\n\n});\n\n\nexport default function scan(obs, fn, seed = NOTHING) {\n  return new P(obs, {fn, seed});\n}\n","import {createStream} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    const xs = fn(x);\n    for (let i = 0; i < xs.length; i++) {\n      this._emitValue(xs[i]);\n    }\n  }\n\n};\n\nconst S = createStream('flatten', mixin);\n\n\nconst id = x => x;\n\nexport default function flatten(obs, fn = id) {\n  return new S(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst END_MARKER = {};\n\nconst mixin = {\n\n  _init({wait}) {\n    this._wait = Math.max(0, wait);\n    this._buff = [];\n    this._$shiftBuff = () => {\n      const value = this._buff.shift();\n      if (value === END_MARKER) {\n        this._emitEnd();\n      } else {\n        this._emitValue(value);\n      }\n    };\n  },\n\n  _free() {\n    this._buff = null;\n    this._$shiftBuff = null;\n  },\n\n  _handleValue(x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._buff.push(x);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  },\n\n  _handleEnd() {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      this._buff.push(END_MARKER);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  }\n\n};\n\nconst S = createStream('delay', mixin);\nconst P = createProperty('delay', mixin);\n\nexport default function delay(obs, wait) {\n  return new (obs._ofSameType(S, P))(obs, {wait});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport now from '../utils/now';\n\n\nconst mixin = {\n\n  _init({wait, leading, trailing}) {\n    this._wait = Math.max(0, wait);\n    this._leading = leading;\n    this._trailing = trailing;\n    this._trailingValue = null;\n    this._timeoutId = null;\n    this._endLater = false;\n    this._lastCallTime = 0;\n    this._$trailingCall = () => this._trailingCall();\n  },\n\n  _free() {\n    this._trailingValue = null;\n    this._$trailingCall = null;\n  },\n\n  _handleValue(x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      let curTime = now();\n      if (this._lastCallTime === 0 && !this._leading) {\n        this._lastCallTime = curTime;\n      }\n      let remaining = this._wait - (curTime - this._lastCallTime);\n      if (remaining <= 0) {\n        this._cancelTrailing();\n        this._lastCallTime = curTime;\n        this._emitValue(x);\n      } else if (this._trailing) {\n        this._cancelTrailing();\n        this._trailingValue = x;\n        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n      }\n    }\n  },\n\n  _handleEnd() {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n\n  _cancelTrailing() {\n    if (this._timeoutId !== null) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = null;\n    }\n  },\n\n  _trailingCall() {\n    this._emitValue(this._trailingValue);\n    this._timeoutId = null;\n    this._trailingValue = null;\n    this._lastCallTime = !this._leading ? 0 : now();\n    if (this._endLater) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('throttle', mixin);\nconst P = createProperty('throttle', mixin);\n\n\nexport default function throttle(obs, wait, {leading = true, trailing = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {wait, leading, trailing});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport now from '../utils/now';\n\n\nconst mixin = {\n\n  _init({wait, immediate}) {\n    this._wait = Math.max(0, wait);\n    this._immediate = immediate;\n    this._lastAttempt = 0;\n    this._timeoutId = null;\n    this._laterValue = null;\n    this._endLater = false;\n    this._$later = () => this._later();\n  },\n\n  _free() {\n    this._laterValue = null;\n    this._$later = null;\n  },\n\n  _handleValue(x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._lastAttempt = now();\n      if (this._immediate && !this._timeoutId) {\n        this._emitValue(x);\n      }\n      if (!this._timeoutId) {\n        this._timeoutId = setTimeout(this._$later, this._wait);\n      }\n      if (!this._immediate) {\n        this._laterValue = x;\n      }\n    }\n  },\n\n  _handleEnd() {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId && !this._immediate) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n\n  _later() {\n    let last = now() - this._lastAttempt;\n    if (last < this._wait && last >= 0) {\n      this._timeoutId = setTimeout(this._$later, this._wait - last);\n    } else {\n      this._timeoutId = null;\n      if (!this._immediate) {\n        this._emitValue(this._laterValue);\n        this._laterValue = null;\n      }\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  }\n\n};\n\nconst S = createStream('debounce', mixin);\nconst P = createProperty('debounce', mixin);\n\nexport default function debounce(obs, wait, {immediate = false} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {wait, immediate});\n}\n\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleError(x) {\n    const fn = this._fn;\n    this._emitError(fn(x));\n  }\n\n};\n\nconst S = createStream('mapErrors', mixin);\nconst P = createProperty('mapErrors', mixin);\n\n\nconst id = x => x;\n\nexport default function mapErrors(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleError(x) {\n    const fn = this._fn;\n    if (fn(x)) {\n      this._emitError(x);\n    }\n  }\n\n};\n\nconst S = createStream('filterErrors', mixin);\nconst P = createProperty('filterErrors', mixin);\n\n\nconst id = x => x;\n\nexport default function filterErrors(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleValue() {}\n};\n\nconst S = createStream('ignoreValues', mixin);\nconst P = createProperty('ignoreValues', mixin);\n\n\nexport default function ignoreValues(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleError() {}\n};\n\nconst S = createStream('ignoreErrors', mixin);\nconst P = createProperty('ignoreErrors', mixin);\n\n\nexport default function ignoreErrors(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleEnd() {}\n};\n\nconst S = createStream('ignoreEnd', mixin);\nconst P = createProperty('ignoreEnd', mixin);\n\n\nexport default function ignoreEnd(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleEnd() {\n    const fn = this._fn;\n    this._emitValue(fn());\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('beforeEnd', mixin);\nconst P = createProperty('beforeEnd', mixin);\n\nexport default function beforeEnd(obs, fn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport {slide} from '../utils/collections';\n\nconst mixin = {\n\n  _init({min, max}) {\n    this._max = max;\n    this._min = min;\n    this._buff = [];\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _handleValue(x) {\n    this._buff = slide(this._buff, x, this._max);\n    if (this._buff.length >= this._min) {\n      this._emitValue(this._buff);\n    }\n  }\n\n};\n\nconst S = createStream('slidingWindow', mixin);\nconst P = createProperty('slidingWindow', mixin);\n\n\nexport default function slidingWindow(obs, max, min = 0) {\n  return new (obs._ofSameType(S, P))(obs, {min, max});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn, flushOnEnd}) {\n    this._fn = fn;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handleValue(x) {\n    this._buff.push(x);\n    const fn = this._fn;\n    if (!fn(x)) {\n      this._flush();\n    }\n  },\n\n  _handleEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('bufferWhile', mixin);\nconst P = createProperty('bufferWhile', mixin);\n\n\nconst id = x => x;\n\nexport default function bufferWhile(obs, fn, {flushOnEnd = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {fn: fn || id, flushOnEnd});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({count, flushOnEnd}) {\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handleValue(x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      this._flush();\n    }\n  },\n\n  _handleEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('bufferWithCount', mixin);\nconst P = createProperty('bufferWithCount', mixin);\n\nexport default function bufferWhile(obs, count, {flushOnEnd = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {count: count, flushOnEnd});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({wait, count, flushOnEnd}) {\n    this._wait = wait;\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._intervalId = null;\n    this._$onTick = () => this._flush();\n    this._buff = [];\n  },\n\n  _free() {\n    this._$onTick = null;\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handleValue(x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      clearInterval(this._intervalId);\n      this._flush();\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    }\n  },\n\n  _handleEnd() {\n    if (this._flushOnEnd && this._buff.length !== 0) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n\n  _onActivation() {\n    this._intervalId = setInterval(this._$onTick, this._wait);\n    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n  },\n\n  _onDeactivation() {\n    if (this._intervalId !== null) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n  }\n\n};\n\n\nconst S = createStream('bufferWithTimeOrCount', mixin);\nconst P = createProperty('bufferWithTimeOrCount', mixin);\n\nexport default function bufferWithTimeOrCount(obs, wait, count, {flushOnEnd = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {wait, count, flushOnEnd});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nfunction xformForObs(obs) {\n  return {\n\n    '@@transducer/step'(res, input) {\n      obs._emitValue(input);\n      return null;\n    },\n\n    '@@transducer/result'() {\n      obs._emitEnd();\n      return null;\n    }\n\n  };\n}\n\nconst mixin = {\n\n  _init({transducer}) {\n    this._xform = transducer(xformForObs(this));\n  },\n\n  _free() {\n    this._xform = null;\n  },\n\n  _handleValue(x) {\n    if (this._xform['@@transducer/step'](null, x) !== null) {\n      this._xform['@@transducer/result'](null);\n    }\n  },\n\n  _handleEnd() {\n    this._xform['@@transducer/result'](null);\n  }\n\n};\n\nconst S = createStream('transduce', mixin);\nconst P = createProperty('transduce', mixin);\n\n\nexport default function transduce(obs, transducer) {\n  return new (obs._ofSameType(S, P))(obs, {transducer});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\nimport emitter from '../emitter';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._handler = fn;\n    this._emitter = emitter(this);\n  },\n\n  _free() {\n    this._handler = null;\n    this._emitter = null;\n  },\n\n  _handleAny(event) {\n    this._handler(this._emitter, event);\n  }\n\n};\n\nconst S = createStream('withHandler', mixin);\nconst P = createProperty('withHandler', mixin);\n\n\n\nexport default function withHandler(obs, fn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import Stream from '../stream';\nimport {VALUE, ERROR, END} from '../constants';\nimport {inherit} from '../utils/objects';\nimport {map, cloneArray} from '../utils/collections';\nimport {spread} from '../utils/functions';\nimport never from '../primary/never';\n\n\nconst isArray = Array.isArray || function(xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\nfunction Zip(sources, combinator) {\n  Stream.call(this);\n\n  this._buffers = map(sources, (source) => isArray(source) ? cloneArray(source) : []);\n  this._sources = map(sources, (source) => isArray(source) ? never() : source);\n\n  this._combinator = combinator ? spread(combinator, this._sources.length) : (x => x);\n  this._aliveCount = 0;\n\n  this._$handlers = [];\n  for (let i = 0; i < this._sources.length; i++) {\n    this._$handlers.push((event) => this._handleAny(i, event));\n  }\n}\n\n\ninherit(Zip, Stream, {\n\n  _name: 'zip',\n\n  _onActivation() {\n\n    // if all sources are arrays\n    while (this._isFull()) {\n      this._emit();\n    }\n\n    const length = this._sources.length;\n    this._aliveCount = length;\n    for (let i = 0; i < length && this._active; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n  },\n\n  _onDeactivation() {\n    for (let i = 0; i < this._sources.length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n\n  _emit() {\n    let values = new Array(this._buffers.length);\n    for (let i = 0; i < this._buffers.length; i++) {\n      values[i] = this._buffers[i].shift();\n    }\n    const combinator = this._combinator;\n    this._emitValue(combinator(values));\n  },\n\n  _isFull() {\n    for (let i = 0; i < this._buffers.length; i++) {\n      if (this._buffers[i].length === 0) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  _handleAny(i, event) {\n    if (event.type === VALUE) {\n      this._buffers[i].push(event.value);\n      if (this._isFull()) {\n        this._emit();\n      }\n    }\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n    if (event.type === END) {\n      this._aliveCount--;\n      if (this._aliveCount === 0) {\n        this._emitEnd();\n      }\n    }\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._buffers = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n\n});\n\n\n\nexport default function zip(observables, combinator /* Function | falsey */) {\n  return observables.length === 0 ? never() : new Zip(observables, combinator);\n}\n","import Stream from '../stream';\nimport {VALUE, ERROR} from '../constants';\nimport {inherit} from '../utils/objects';\nimport {concat, forEach, findByPred, find, remove, cloneArray} from '../utils/collections';\n\nconst id = (x => x);\n\nfunction AbstractPool({queueLim = 0, concurLim = -1, drop = 'new'} = {}) {\n  Stream.call(this);\n\n  this._queueLim = queueLim < 0 ? -1 : queueLim;\n  this._concurLim = concurLim < 0 ? -1 : concurLim;\n  this._drop = drop;\n  this._queue = [];\n  this._curSources = [];\n  this._$handleSubAny = (event) => this._handleSubAny(event);\n  this._$endHandlers = [];\n  this._currentlyAdding = null;\n\n  if (this._concurLim === 0) {\n    this._emitEnd();\n  }\n}\n\ninherit(AbstractPool, Stream, {\n\n  _name: 'abstractPool',\n\n  _add(obj, toObs /* Function | falsey */) {\n    toObs = toObs || id;\n    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n      this._addToCur(toObs(obj));\n    } else {\n      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n        this._addToQueue(toObs(obj));\n      } else if (this._drop === 'old') {\n        this._removeOldest();\n        this._add(obj, toObs);\n      }\n    }\n  },\n\n  _addAll(obss) {\n    forEach(obss, (obs) => this._add(obs));\n  },\n\n  _remove(obs) {\n    if (this._removeCur(obs) === -1) {\n      this._removeQueue(obs);\n    }\n  },\n\n  _addToQueue(obs) {\n    this._queue = concat(this._queue, [obs]);\n  },\n\n  _addToCur(obs) {\n    if (this._active) {\n\n      // HACK:\n      //\n      // We have two optimizations for cases when `obs` is ended. We don't want\n      // to add such observable to the list, but only want to emit events\n      // from it (if it has some).\n      //\n      // Instead of this hacks, we could just did following,\n      // but it would be 5-8 times slower:\n      //\n      //     this._curSources = concat(this._curSources, [obs]);\n      //     this._subscribe(obs);\n      //\n\n      // #1\n      // This one for cases when `obs` already ended\n      // e.g., Kefir.constant() or Kefir.never()\n      if (!obs._alive) {\n        if (obs._currentEvent) {\n          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n        }\n        return;\n      }\n\n      // #2\n      // This one is for cases when `obs` going to end synchronously on\n      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n      this._currentlyAdding = obs;\n      obs.onAny(this._$handleSubAny);\n      this._currentlyAdding = null;\n      if (obs._alive) {\n        this._curSources = concat(this._curSources, [obs]);\n        if (this._active) {\n          this._subToEnd(obs);\n        }\n      }\n\n    } else {\n      this._curSources = concat(this._curSources, [obs]);\n    }\n  },\n\n  _subToEnd(obs) {\n    const onEnd = () => this._removeCur(obs);\n    this._$endHandlers.push({obs: obs, handler: onEnd});\n    obs.onEnd(onEnd);\n  },\n\n  _subscribe(obs) {\n    obs.onAny(this._$handleSubAny);\n\n    // it can become inactive in responce of subscribing to `obs.onAny` above\n    if (this._active) {\n      this._subToEnd(obs);\n    }\n  },\n\n  _unsubscribe(obs) {\n    obs.offAny(this._$handleSubAny);\n\n    let onEndI = findByPred(this._$endHandlers, (obj) => obj.obs === obs);\n    if (onEndI !== -1) {\n      obs.offEnd(this._$endHandlers[onEndI].handler);\n      this._$endHandlers.splice(onEndI, 1);\n    }\n  },\n\n  _handleSubAny(event) {\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    } else if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n  },\n\n  _removeQueue(obs) {\n    let index = find(this._queue, obs);\n    this._queue = remove(this._queue, index);\n    return index;\n  },\n\n  _removeCur(obs) {\n    if (this._active) {\n      this._unsubscribe(obs);\n    }\n    let index = find(this._curSources, obs);\n    this._curSources = remove(this._curSources, index);\n    if (index !== -1) {\n      if (this._queue.length !== 0) {\n        this._pullQueue();\n      } else if (this._curSources.length === 0) {\n        this._onEmpty();\n      }\n    }\n    return index;\n  },\n\n  _removeOldest() {\n    this._removeCur(this._curSources[0]);\n  },\n\n  _pullQueue() {\n    if (this._queue.length !== 0) {\n      this._queue = cloneArray(this._queue);\n      this._addToCur(this._queue.shift());\n    }\n  },\n\n  _onActivation() {\n    for (let i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n      this._subscribe(sources[i]);\n    }\n  },\n\n  _onDeactivation() {\n    for (let i = 0, sources = this._curSources; i < sources.length; i++) {\n      this._unsubscribe(sources[i]);\n    }\n    if (this._currentlyAdding !== null) {\n      this._unsubscribe(this._currentlyAdding);\n    }\n  },\n\n  _isEmpty() {\n    return this._curSources.length === 0;\n  },\n\n  _onEmpty() {},\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._queue = null;\n    this._curSources = null;\n    this._$handleSubAny = null;\n    this._$endHandlers = null;\n  }\n\n});\n\nexport default AbstractPool;\n","import {inherit} from '../utils/objects';\nimport AbstractPool from './abstract-pool';\nimport never from '../primary/never';\n\n\nfunction Merge(sources) {\n  AbstractPool.call(this);\n  this._addAll(sources);\n  this._initialised = true;\n}\n\ninherit(Merge, AbstractPool, {\n\n  _name: 'merge',\n\n  _onEmpty() {\n    if (this._initialised) {\n      this._emitEnd();\n    }\n  }\n\n});\n\nexport default function merge(observables) {\n  return observables.length === 0 ? never() : new Merge(observables);\n}\n","import {inherit} from '../utils/objects';\nimport Stream from '../stream';\nimport {END} from '../constants';\n\n\n\nfunction S(generator) {\n  Stream.call(this);\n  this._generator = generator;\n  this._source = null;\n  this._inLoop = false;\n  this._iteration = 0;\n  this._$handleAny = (event) => this._handleAny(event);\n}\n\ninherit(S, Stream, {\n\n  _name: 'repeat',\n\n  _handleAny(event) {\n    if (event.type === END) {\n      this._source = null;\n      this._getSource();\n    } else {\n      this._emit(event.type, event.value);\n    }\n  },\n\n  _getSource() {\n    if (!this._inLoop) {\n      this._inLoop = true;\n      const generator = this._generator;\n      while (this._source === null && this._alive && this._active) {\n        this._source = generator(this._iteration++);\n        if (this._source) {\n          this._source.onAny(this._$handleAny);\n        } else {\n          this._emitEnd();\n        }\n      }\n      this._inLoop = false;\n    }\n  },\n\n  _onActivation() {\n    if (this._source) {\n      this._source.onAny(this._$handleAny);\n    } else {\n      this._getSource();\n    }\n  },\n\n  _onDeactivation() {\n    if (this._source) {\n      this._source.offAny(this._$handleAny);\n    }\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._generator = null;\n    this._source = null;\n    this._$handleAny = null;\n  }\n\n});\n\n\nexport default function(generator) {\n  return new S(generator);\n}\n","import repeat from './repeat';\n\nexport default function concat(observables) {\n  return repeat(function(index) {\n    return observables.length > index ? observables[index] : false;\n  }).setName('concat');\n}\n","import {inherit} from '../utils/objects';\nimport AbstractPool from './abstract-pool';\n\n\n\nfunction Pool() {\n  AbstractPool.call(this);\n}\n\ninherit(Pool, AbstractPool, {\n\n  _name: 'pool',\n\n  plug(obs) {\n    this._add(obs);\n    return this;\n  },\n\n  unplug(obs) {\n    this._remove(obs);\n    return this;\n  }\n\n});\n\nexport default Pool;\n","import {VALUE, ERROR, END} from '../constants';\nimport {inherit} from '../utils/objects';\nimport AbstractPool from './abstract-pool';\n\n\n\n\nfunction FlatMap(source, fn, options) {\n  AbstractPool.call(this, options);\n  this._source = source;\n  this._fn = fn;\n  this._mainEnded = false;\n  this._lastCurrent = null;\n  this._$handleMain = (event) => this._handleMain(event);\n}\n\ninherit(FlatMap, AbstractPool, {\n\n  _onActivation() {\n    AbstractPool.prototype._onActivation.call(this);\n    if (this._active) {\n      this._source.onAny(this._$handleMain);\n    }\n  },\n\n  _onDeactivation() {\n    AbstractPool.prototype._onDeactivation.call(this);\n    this._source.offAny(this._$handleMain);\n    this._hadNoEvSinceDeact = true;\n  },\n\n  _handleMain(event) {\n\n    if (event.type === VALUE) {\n      // Is latest value before deactivation survived, and now is 'current' on this activation?\n      // We don't want to handle such values, to prevent to constantly add\n      // same observale on each activation/deactivation when our main source\n      // is a `Kefir.conatant()` for example.\n      let sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n\n  },\n\n  _onEmpty() {\n    if (this._mainEnded) {\n      this._emitEnd();\n    }\n  },\n\n  _clear() {\n    AbstractPool.prototype._clear.call(this);\n    this._source = null;\n    this._lastCurrent = null;\n    this._$handleMain = null;\n  }\n\n});\n\n\n\n\nexport default FlatMap;\n","import {VALUE, ERROR, END} from '../constants';\nimport {inherit} from '../utils/objects';\nimport FlatMap from './flat-map';\n\nfunction FlatMapErrors(source, fn) {\n  FlatMap.call(this, source, fn);\n}\n\ninherit(FlatMapErrors, FlatMap, {\n\n  // Same as in FlatMap, only VALUE/ERROR flipped\n  _handleMain(event) {\n\n    if (event.type === ERROR) {\n      let sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n\n  }\n\n\n\n});\n\nexport default FlatMapErrors;\n","import Stream from '../stream';\nimport Property from '../property';\nimport {inherit} from '../utils/objects';\nimport {VALUE, ERROR, END, NOTHING} from '../constants';\n\n\n\n\n\nfunction createConstructor(BaseClass, name) {\n  return function AnonymousObservable(primary, secondary, options) {\n    BaseClass.call(this);\n    this._primary = primary;\n    this._secondary = secondary;\n    this._name = `${primary._name}.${name}`;\n    this._lastSecondary = NOTHING;\n    this._$handleSecondaryAny = (event) => this._handleSecondaryAny(event);\n    this._$handlePrimaryAny = (event) => this._handlePrimaryAny(event);\n    this._init(options);\n  }\n}\n\nfunction createClassMethods(BaseClass) {\n  return {\n    _init() {},\n    _free() {},\n\n    _handlePrimaryValue(x) {\n      this._emitValue(x);\n    },\n    _handlePrimaryError(x) {\n      this._emitError(x);\n    },\n    _handlePrimaryEnd() {\n      this._emitEnd();\n    },\n\n    _handleSecondaryValue(x) {\n      this._lastSecondary = x;\n    },\n    _handleSecondaryError(x) {\n      this._emitError(x);\n    },\n    _handleSecondaryEnd() {},\n\n    _handlePrimaryAny(event) {\n      switch (event.type) {\n        case VALUE: return this._handlePrimaryValue(event.value);\n        case ERROR: return this._handlePrimaryError(event.value);\n        case END: return this._handlePrimaryEnd(event.value);\n      }\n    },\n    _handleSecondaryAny(event) {\n      switch (event.type) {\n        case VALUE: return this._handleSecondaryValue(event.value);\n        case ERROR: return this._handleSecondaryError(event.value);\n        case END:\n          this._handleSecondaryEnd(event.value);\n          this._removeSecondary();\n      }\n    },\n\n    _removeSecondary() {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n        this._$handleSecondaryAny = null;\n        this._secondary = null;\n      }\n    },\n\n    _onActivation() {\n      if (this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n      if (this._active) {\n        this._primary.onAny(this._$handlePrimaryAny);\n      }\n    },\n    _onDeactivation() {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n      }\n      this._primary.offAny(this._$handlePrimaryAny);\n    },\n\n    _clear() {\n      BaseClass.prototype._clear.call(this);\n      this._primary = null;\n      this._secondary = null;\n      this._lastSecondary = null;\n      this._$handleSecondaryAny = null;\n      this._$handlePrimaryAny = null;\n      this._free();\n    }\n\n  };\n}\n\n\n\nfunction createStream(name, mixin) {\n  const S = createConstructor(Stream, name);\n  inherit(S, Stream, createClassMethods(Stream), mixin);\n  return S;\n}\n\n\nfunction createProperty(name, mixin) {\n  const P = createConstructor(Property, name);\n  inherit(P, Property, createClassMethods(Property), mixin);\n  return P;\n}\n\n\nexport {createStream, createProperty};\n\n","import {createStream, createProperty} from '../patterns/two-sources';\nimport {NOTHING} from '../constants';\n\n\nconst mixin = {\n\n  _handlePrimaryValue(x) {\n    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n      this._emitValue(x);\n    }\n  },\n\n  _handleSecondaryEnd() {\n    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('filterBy', mixin);\nconst P = createProperty('filterBy', mixin);\n\n\nexport default function filterBy(primary, secondary) {\n  return new (primary._ofSameType(S, P))(primary, secondary);\n}\n\n","import combine from '../many-sources/combine';\n\nconst id2 = (_, x) => x;\n\nexport default function sampledBy(passive, active, combinator) {\n  let _combinator = combinator ? ((a, b) => combinator(b, a)) : id2;\n  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n}\n","import {createStream, createProperty} from '../patterns/two-sources';\nimport {NOTHING} from '../constants';\n\n\nconst mixin = {\n\n  _handlePrimaryValue(x) {\n    if (this._lastSecondary !== NOTHING) {\n      this._emitValue(x);\n    }\n  },\n\n  _handleSecondaryEnd() {\n    if (this._lastSecondary === NOTHING) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('skipUntilBy', mixin);\nconst P = createProperty('skipUntilBy', mixin);\n\n\nexport default function skipUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S, P))(primary, secondary);\n}\n\n","import {createStream, createProperty} from '../patterns/two-sources';\n\nconst mixin = {\n\n  _handleSecondaryValue() {\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('takeUntilBy', mixin);\nconst P = createProperty('takeUntilBy', mixin);\n\n\nexport default function takeUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S, P))(primary, secondary);\n}\n\n","import {createStream, createProperty} from '../patterns/two-sources';\n\n\nconst mixin = {\n\n  _init({flushOnEnd = true} = {}) {\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handlePrimaryEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n\n  _onActivation() {\n    this._primary.onAny(this._$handlePrimaryAny);\n    if (this._alive && this._secondary !== null) {\n      this._secondary.onAny(this._$handleSecondaryAny);\n    }\n  },\n\n  _handlePrimaryValue(x) {\n    this._buff.push(x);\n  },\n\n  _handleSecondaryValue() {\n    this._flush();\n  },\n\n  _handleSecondaryEnd() {\n    if (!this._flushOnEnd) {\n      this._emitEnd();\n    }\n  }\n\n};\n\n\nconst S = createStream('bufferBy', mixin);\nconst P = createProperty('bufferBy', mixin);\n\n\nexport default function bufferBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S, P))(primary, secondary, options);\n}\n","import {createStream, createProperty} from '../patterns/two-sources';\nimport {NOTHING} from '../constants';\n\n\nconst mixin = {\n\n  _init({flushOnEnd = true, flushOnChange = false} = {}) {\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n    this._flushOnChange = flushOnChange;\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handlePrimaryEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n\n  _handlePrimaryValue(x) {\n    this._buff.push(x);\n    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n      this._flush();\n    }\n  },\n\n  _handleSecondaryEnd() {\n    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n      this._emitEnd();\n    }\n  },\n\n  _handleSecondaryValue(x) {\n    if (this._flushOnChange && !x) {\n      this._flush();\n    }\n\n    // from default _handleSecondaryValue\n    this._lastSecondary = x;\n  }\n\n};\n\n\nconst S = createStream('bufferWhileBy', mixin);\nconst P = createProperty('bufferWhileBy', mixin);\n\n\nexport default function bufferWhileBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S, P))(primary, secondary, options);\n}\n","import merge from '../many-sources/merge';\nimport map from '../one-source/map';\nimport skipDuplicates from '../one-source/skip-duplicates';\nimport toProperty from '../one-source/to-property';\n\nconst f = () => false;\nconst t = () => true;\n\nexport default function awaiting(a, b) {\n  let result = merge([map(a, t), map(b, f)]);\n  result = skipDuplicates(result);\n  result = toProperty(result, f);\n  return result.setName(a, 'awaiting');\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    let result = fn(x);\n    if (result.convert) {\n      this._emitError(result.error);\n    } else {\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('valuesToErrors', mixin);\nconst P = createProperty('valuesToErrors', mixin);\n\n\nconst defFn = x => ({convert: true, error: x});\n\nexport default function valuesToErrors(obs, fn = defFn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleError(x) {\n    const fn = this._fn;\n    const result = fn(x);\n    if (result.convert) {\n      this._emitValue(result.value);\n    } else {\n      this._emitError(x);\n    }\n  }\n\n};\n\nconst S = createStream('errorsToValues', mixin);\nconst P = createProperty('errorsToValues', mixin);\n\n\nconst defFn = x => ({convert: true, value: x});\n\nexport default function errorsToValues(obs, fn = defFn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _handleError(x) {\n    this._emitError(x);\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('endOnError', mixin);\nconst P = createProperty('endOnError', mixin);\n\n\nexport default function endOnError(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","import Observable from './observable';\nimport Stream from './stream';\nimport Property from './property';\n\n\n\n// Create a stream\n// -----------------------------------------------------------------------------\n\n// () -> Stream\nimport never from './primary/never';\n\n// (number, any) -> Stream\nimport later from './time-based/later';\n\n// (number, any) -> Stream\nimport interval from './time-based/interval';\n\n// (number, Array<any>) -> Stream\nimport sequentially from './time-based/sequentially';\n\n// (number, Function) -> Stream\nimport fromPoll from './time-based/from-poll';\n\n// (number, Function) -> Stream\nimport withInterval from './time-based/with-interval';\n\n// (Function) -> Stream\nimport fromCallback from './primary/from-callback';\n\n// (Function) -> Stream\nimport fromNodeCallback from './primary/from-node-callback';\n\n// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}\n// (Target, string, Function|undefined) -> Stream\nimport fromEvents from './primary/from-events';\n\n// (Function) -> Stream\nimport stream from './primary/stream';\n\n\n\n// Create a property\n// -----------------------------------------------------------------------------\n\n// (any) -> Property\nimport constant from './primary/constant';\n\n// (any) -> Property\nimport constantError from './primary/constant-error';\n\n\n\n// Convert observables\n// -----------------------------------------------------------------------------\n\n// (Stream|Property, Function|undefined) -> Property\nimport toProperty from './one-source/to-property';\nObservable.prototype.toProperty = function(fn) {\n  return toProperty(this, fn);\n};\n\n// (Stream|Property) -> Stream\nimport changes from './one-source/changes';\nObservable.prototype.changes = function() {\n  return changes(this);\n};\n\n\n\n// Interoperation with other implimentations\n// -----------------------------------------------------------------------------\n\n// (Promise) -> Property\nimport fromPromise from './interop/from-promise';\n\n// (Stream|Property, Function|undefined) -> Promise\nimport toPromise from './interop/to-promise';\nObservable.prototype.toPromise = function(Promise) {\n  return toPromise(this, Promise);\n};\n\n// (ESObservable) -> Stream\nimport fromESObservable from './interop/from-es-observable';\n\n// (Stream|Property) -> ES7 Observable\nimport toESObservable from './interop/to-es-observable';\nObservable.prototype.toESObservable = toESObservable;\nimport $$observable from 'symbol-observable';\nObservable.prototype[$$observable] = toESObservable;\n\nimport * as staticLand from './interop/static-land'\n\n\n// Modify an observable\n// -----------------------------------------------------------------------------\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport map from './one-source/map';\nObservable.prototype.map = function(fn) {\n  return map(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport filter from './one-source/filter';\nObservable.prototype.filter = function(fn) {\n  return filter(this, fn);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nimport take from './one-source/take';\nObservable.prototype.take = function(n) {\n  return take(this, n);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nimport takeErrors from './one-source/take-errors';\nObservable.prototype.takeErrors = function(n) {\n  return takeErrors(this, n);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport takeWhile from './one-source/take-while';\nObservable.prototype.takeWhile = function(fn) {\n  return takeWhile(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nimport last from './one-source/last';\nObservable.prototype.last = function() {\n  return last(this);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nimport skip from './one-source/skip';\nObservable.prototype.skip = function(n) {\n  return skip(this, n);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport skipWhile from './one-source/skip-while';\nObservable.prototype.skipWhile = function(fn) {\n  return skipWhile(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport skipDuplicates from './one-source/skip-duplicates';\nObservable.prototype.skipDuplicates = function(fn) {\n  return skipDuplicates(this, fn);\n};\n\n// (Stream, Function|falsey, any|undefined) -> Stream\n// (Property, Function|falsey, any|undefined) -> Property\nimport diff from './one-source/diff';\nObservable.prototype.diff = function(fn, seed) {\n  return diff(this, fn, seed);\n};\n\n// (Stream|Property, Function, any|undefined) -> Property\nimport scan from './one-source/scan';\nObservable.prototype.scan = function(fn, seed) {\n  return scan(this, fn, seed);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport flatten from './one-source/flatten';\nObservable.prototype.flatten = function(fn) {\n  return flatten(this, fn);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nimport delay from './one-source/delay';\nObservable.prototype.delay = function(wait) {\n  return delay(this, wait);\n};\n\n// Options = {leading: boolean|undefined, trailing: boolean|undefined}\n// (Stream, number, Options|undefined) -> Stream\n// (Property, number, Options|undefined) -> Property\nimport throttle from './one-source/throttle';\nObservable.prototype.throttle = function(wait, options) {\n  return throttle(this, wait, options);\n};\n\n// Options = {immediate: boolean|undefined}\n// (Stream, number, Options|undefined) -> Stream\n// (Property, number, Options|undefined) -> Property\nimport debounce from './one-source/debounce';\nObservable.prototype.debounce = function(wait, options) {\n  return debounce(this, wait, options);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport mapErrors from './one-source/map-errors';\nObservable.prototype.mapErrors = function(fn) {\n  return mapErrors(this, fn);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport filterErrors from './one-source/filter-errors';\nObservable.prototype.filterErrors = function(fn) {\n  return filterErrors(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nimport ignoreValues from './one-source/ignore-values';\nObservable.prototype.ignoreValues = function() {\n  return ignoreValues(this);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nimport ignoreErrors from './one-source/ignore-errors';\nObservable.prototype.ignoreErrors = function() {\n  return ignoreErrors(this);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nimport ignoreEnd from './one-source/ignore-end';\nObservable.prototype.ignoreEnd = function() {\n  return ignoreEnd(this);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nimport beforeEnd from './one-source/before-end';\nObservable.prototype.beforeEnd = function(fn) {\n  return beforeEnd(this, fn);\n};\n\n// (Stream, number, number|undefined) -> Stream\n// (Property, number, number|undefined) -> Property\nimport slidingWindow from './one-source/sliding-window';\nObservable.prototype.slidingWindow = function(max, min) {\n  return slidingWindow(this, max, min);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Function|falsey, Options|undefined) -> Stream\n// (Property, Function|falsey, Options|undefined) -> Property\nimport bufferWhile from './one-source/buffer-while';\nObservable.prototype.bufferWhile = function(fn, options) {\n  return bufferWhile(this, fn, options);\n};\n\n// (Stream, number) -> Stream\n// (Property, number) -> Property\nimport bufferWithCount from './one-source/buffer-with-count';\nObservable.prototype.bufferWithCount = function(count, options) {\n  return bufferWithCount(this, count, options);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, number, number, Options|undefined) -> Stream\n// (Property, number, number, Options|undefined) -> Property\nimport bufferWithTimeOrCount from './one-source/buffer-with-time-or-count';\nObservable.prototype.bufferWithTimeOrCount = function(wait, count, options) {\n  return bufferWithTimeOrCount(this, wait, count, options);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nimport transduce from './one-source/transduce';\nObservable.prototype.transduce = function(transducer) {\n  return transduce(this, transducer);\n};\n\n// (Stream, Function) -> Stream\n// (Property, Function) -> Property\nimport withHandler from './one-source/with-handler';\nObservable.prototype.withHandler = function(fn) {\n  return withHandler(this, fn);\n};\n\n\n\n// Combine observables\n// -----------------------------------------------------------------------------\n\n// (Array<Stream|Property>, Function|undefiend) -> Stream\n// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream\nimport combine from './many-sources/combine';\nObservable.prototype.combine = function(other, combinator) {\n  return combine([this, other], combinator);\n};\n\n// (Array<Stream|Property>, Function|undefiend) -> Stream\nimport zip from './many-sources/zip';\nObservable.prototype.zip = function(other, combinator) {\n  return zip([this, other], combinator);\n};\n\n// (Array<Stream|Property>) -> Stream\nimport merge from './many-sources/merge';\nObservable.prototype.merge = function(other) {\n  return merge([this, other]);\n};\n\n// (Array<Stream|Property>) -> Stream\nimport concat from './many-sources/concat';\nObservable.prototype.concat = function(other) {\n  return concat([this, other]);\n};\n\n// () -> Pool\nimport Pool from './many-sources/pool';\nconst pool = function() {\n  return new Pool();\n};\n\n// (Function) -> Stream\nimport repeat from './many-sources/repeat';\n\n// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}\n// (Stream|Property, Function|falsey, Options|undefined) -> Stream\nimport FlatMap from './many-sources/flat-map';\nObservable.prototype.flatMap = function(fn) {\n  return new FlatMap(this, fn).setName(this, 'flatMap');\n};\nObservable.prototype.flatMapLatest = function(fn) {\n  return new FlatMap(this, fn, {concurLim: 1, drop: 'old'}).setName(this, 'flatMapLatest');\n};\nObservable.prototype.flatMapFirst = function(fn) {\n  return new FlatMap(this, fn, {concurLim: 1}).setName(this, 'flatMapFirst');\n};\nObservable.prototype.flatMapConcat = function(fn) {\n  return new FlatMap(this, fn, {queueLim: -1, concurLim: 1}).setName(this, 'flatMapConcat');\n};\nObservable.prototype.flatMapConcurLimit = function(fn, limit) {\n  return new FlatMap(this, fn, {queueLim: -1, concurLim: limit}).setName(this, 'flatMapConcurLimit');\n};\n\n// (Stream|Property, Function|falsey) -> Stream\nimport FlatMapErrors from './many-sources/flat-map-errors';\nObservable.prototype.flatMapErrors = function(fn) {\n  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n};\n\n\n\n// Combine two observables\n// -----------------------------------------------------------------------------\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nimport filterBy from './two-sources/filter-by';\nObservable.prototype.filterBy = function(other) {\n  return filterBy(this, other);\n};\n\n// (Stream, Stream|Property, Function|undefiend) -> Stream\n// (Property, Stream|Property, Function|undefiend) -> Property\nimport sampledBy2items from './two-sources/sampled-by';\nObservable.prototype.sampledBy = function(other, combinator) {\n  return sampledBy2items(this, other, combinator);\n};\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nimport skipUntilBy from './two-sources/skip-until-by';\nObservable.prototype.skipUntilBy = function(other) {\n  return skipUntilBy(this, other);\n};\n\n// (Stream, Stream|Property) -> Stream\n// (Property, Stream|Property) -> Property\nimport takeUntilBy from './two-sources/take-until-by';\nObservable.prototype.takeUntilBy = function(other) {\n  return takeUntilBy(this, other);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Stream|Property, Options|undefined) -> Stream\n// (Property, Stream|Property, Options|undefined) -> Property\nimport bufferBy from './two-sources/buffer-by';\nObservable.prototype.bufferBy = function(other, options) {\n  return bufferBy(this, other, options);\n};\n\n// Options = {flushOnEnd: boolean|undefined}\n// (Stream, Stream|Property, Options|undefined) -> Stream\n// (Property, Stream|Property, Options|undefined) -> Property\nimport bufferWhileBy from './two-sources/buffer-while-by';\nObservable.prototype.bufferWhileBy = function(other, options) {\n  return bufferWhileBy(this, other, options);\n};\n\n\n\n// Deprecated\n// -----------------------------------------------------------------------------\n\nlet DEPRECATION_WARNINGS = true\nexport function dissableDeprecationWarnings() {\n  DEPRECATION_WARNINGS = false\n}\n\nfunction warn(msg) {\n  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n    const msg2 = '\\nHere is an Error object for you containing the call stack:';\n    console.warn(msg, msg2, new Error());\n  }\n}\n\n// (Stream|Property, Stream|Property) -> Property\nimport awaiting from './two-sources/awaiting';\nObservable.prototype.awaiting = function(other) {\n  warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145')\n  return awaiting(this, other);\n};\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport valuesToErrors from './one-source/values-to-errors';\nObservable.prototype.valuesToErrors = function(fn) {\n  warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149')\n  return valuesToErrors(this, fn);\n};\n\n\n// (Stream, Function|undefined) -> Stream\n// (Property, Function|undefined) -> Property\nimport errorsToValues from './one-source/errors-to-values';\nObservable.prototype.errorsToValues = function(fn) {\n  warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149')\n  return errorsToValues(this, fn);\n};\n\n// (Stream) -> Stream\n// (Property) -> Property\nimport endOnError from './one-source/end-on-error';\nObservable.prototype.endOnError = function() {\n  warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150')\n  return endOnError(this);\n};\n\n\n\n// Exports\n// --------------------------------------------------------------------------\n\nconst Kefir = { Observable, Stream, Property, never, later, interval, sequentially,\nfromPoll, withInterval, fromCallback, fromNodeCallback, fromEvents, stream,\nconstant, constantError, fromPromise, fromESObservable, combine, zip, merge,\nconcat, Pool, pool, repeat, staticLand };\n\nKefir.Kefir = Kefir;\n\nexport { Kefir, Observable, Stream, Property, never, later, interval, sequentially,\nfromPoll, withInterval, fromCallback, fromNodeCallback, fromEvents, stream,\nconstant, constantError, fromPromise, fromESObservable, combine, zip, merge,\nconcat, Pool, pool, repeat, staticLand };\n\nexport default Kefir\n","export const NOTHING = ['<nothing>'];\nexport const END = 'end';\nexport const VALUE = 'value';\nexport const ERROR = 'error';\nexport const ANY = 'any';\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;","module.exports = require('./lib/index');\n","import constant from '../primary/constant';\nimport never from '../primary/never';\nimport combine from '../many-sources/combine';\n\nconst Observable = {\n\n  empty() {\n    return never();\n  },\n\n  // Monoid based on merge() seems more useful than one based on concat().\n  concat(a, b) {\n    return a.merge(b);\n  },\n\n  of(x) {\n    return constant(x);\n  },\n\n  map(fn, obs) {\n    return obs.map(fn);\n  },\n\n  bimap(fnErr, fnVal, obs) {\n    return obs.mapErrors(fnErr).map(fnVal);\n  },\n\n  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n  // different (not very useful) behavior. But spec requires that if method can be derived\n  // it must have the same behavior as hand-written method. We intentionally violate the spec\n  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n  ap(obsFn, obsVal) {\n    return combine([obsFn, obsVal], (fn, val) => fn(val));\n  },\n\n  chain(fn, obs) {\n    return obs.flatMap(fn);\n  }\n\n}\n\nexport {Observable}\n","export default Date.now ?\n  (() => Date.now()) :\n  (() => new Date().getTime());\n"],"names":["createObj","proto","F","prototype","extend","target","length","arguments","i","prop","inherit","Child","Parent","constructor","concat","a","b","result","j","Array","find","arr","value","findByPred","pred","cloneArray","input","remove","index","map","fn","forEach","fillArray","contains","slide","cur","next","max","Math","min","offset","callSubscriber","type","event","ANY","VALUE","ERROR","Dispatcher","_items","_spies","_inLoop","_removedItems","Observable","_dispatcher","_active","_alive","_activating","_logHandlers","_spyHandlers","Stream","call","this","Property","_currentEvent","never","neverS","timeBased","mixin","AnonymousStream","wait","options","_wait","_intervalId","_$onTick","_this","_onTick","_init","setInterval","_clear","_free","later","x","S","interval","sequentially","xs","fromPoll","emitter","obs","_emitValue","error","_emitError","end","_emitEnd","e","_emit","withInterval","_fn","_unsubscribe","stream","fromCallback","callbackConsumer","called","emit","setName","fromNodeCallback","spread","apply","c","aLength","fromSubUnsub","sub","unsub","transformer","handler","fromEvents","eventName","pairs","undefined","Error","P","current","constant","constantError","createConstructor","BaseClass","name","source","_source","_name","_$handleAny","_handleAny","createClassMethods","_handleValue","_handleError","END","_handleEnd","onAny","offAny","createStream","createProperty","toProperty","changes","fromPromise","promise","onValue","onError","_promise","then","done","getGlodalPromise","Promise","last","resolve","reject","fromESObservable","_observable","observable","$$observable","subscribe","unsubscribe","ESObservable","takeErrors","toESObservable","collect","keys","values","hasOwnProperty","push","defaultErrorsCombinator","errors","latestError","Combine","active","passive","combinator","_activeCount","_sources","_combinator","_aliveCount","_latestValues","_latestErrors","NOTHING","_emitAfterActivation","_endAfterActivation","_latestErrorIndex","_$handlers","combineAsArray","isArray","combineAsObject","activeObservables","passiveObservables","objectify","combine","id","_ofSameType","filter","take","n","takeWhile","skip","skipWhile","skipDuplicates","eq","defaultFn","diff","seed","scan","flatten","delay","throttle","leading","trailing","debounce","immediate","mapErrors","filterErrors","ignoreValues","ignoreErrors","ignoreEnd","beforeEnd","slidingWindow","bufferWhile","flushOnEnd","count","bufferWithTimeOrCount","xformForObs","res","transduce","transducer","withHandler","Zip","sources","_buffers","zip","observables","AbstractPool","queueLim","concurLim","drop","_queueLim","_concurLim","_drop","_queue","_curSources","_$handleSubAny","_handleSubAny","_$endHandlers","_currentlyAdding","Merge","_addAll","_initialised","merge","generator","_generator","_iteration","repeat","Pool","FlatMap","_mainEnded","_lastCurrent","_$handleMain","_handleMain","FlatMapErrors","primary","secondary","_primary","_secondary","_lastSecondary","_$handleSecondaryAny","_handleSecondaryAny","_$handlePrimaryAny","_handlePrimaryAny","_handlePrimaryValue","_handlePrimaryError","_handlePrimaryEnd","_handleSecondaryValue","_handleSecondaryError","_handleSecondaryEnd","_removeSecondary","filterBy","sampledBy","id2","skipUntilBy","takeUntilBy","bufferBy","bufferWhileBy","awaiting","t","f","valuesToErrors","defFn","errorsToValues","endOnError","dissableDeprecationWarnings","warn","msg","DEPRECATION_WARNINGS","console","msg2","indexOf","spies","items","_onActivation","_onDeactivation","_setActive","cleanup","dispatch","add","_on","_off","observerOrOnValue","onEnd","closed","observer","A","B","getType","sourceObs","selfName","toString","isCurrent","log","handlerIndex","obj","splice","addSpy","removeSpy","_x","_xs","shift","_emitter","_callUnsubscribe","_getInitialCurrent","getInitial","symbolObservablePonyfill","root","_Symbol","Symbol","Object","defineProperty","exports","_interopRequireDefault","__esModule","default","_ponyfill","require","_ponyfill2","self","window","global","module","Function","observerOrOnNext","onComplete","complete","subscription","_emitIfFull","hasAllValues","hasErrors","valuesCopy","errorsCopy","fnErr","fnVal","obsFn","obsVal","val","flatMap","_n","_lastValue","_prev","_seed","END_MARKER","_buff","_$shiftBuff","Date","now","getTime","_leading","_trailing","_trailingValue","_timeoutId","_endLater","_lastCallTime","_$trailingCall","_trailingCall","curTime","remaining","_cancelTrailing","setTimeout","_immediate","_lastAttempt","_laterValue","_$later","_later","_max","_min","_flushOnEnd","_flush","_count","_xform","_handler","_isFull","toObs","_addToCur","_addToQueue","_removeOldest","_add","obss","_this2","_removeCur","_removeQueue","_subToEnd","_this3","onEndI","offEnd","_pullQueue","_onEmpty","_subscribe","_getSource","_remove","_hadNoEvSinceDeact","sameCurr","_isEmpty","_","flushOnChange","_flushOnChange","convert","toPromise","bufferWithCount","other","pool","flatMapLatest","flatMapFirst","flatMapConcat","flatMapConcurLimit","limit","flatMapErrors","sampledBy2items","Kefir","staticLand"],"mappings":"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"}