{"version":3,"sources":["src/storage/implementation/backoff.ts"],"names":["start","stop","f","callback","timeout","waitSeconds","timeoutId","hitTimeout","cancelState","canceled","triggeredCallback","triggerCallback","apply","arguments","callWithDelay","millis","setTimeout","handler","success","var_args","mustStop","waitMillis","Math","random","stopped","wasTimeout","clearTimeout","id"],"mappings":";;;;;QA8BMA,K,GAAAA,K;QA8FAC,I,GAAAA,I;AA5HN;;;;;;;;;;;;;;;AAwBA;;;;;;AAMM,SAAAD,KAAA,CACFE,CADE,EAGFC,QAHE,EAGkBC,OAHlB,EAGiC;AACrC;AACA;AACA,QAAIC,cAAc,CAAlB;AACA;AACA,QAAIC,YAAiB,IAArB;AACA,QAAIC,aAAa,KAAjB;AACA,QAAIC,cAAc,CAAlB;AAEA,aAAAC,QAAA,GAAA;AACE,eAAOD,gBAAgB,CAAvB;AACD;AACD,QAAIE,oBAAoB,KAAxB;AAEA,aAAAC,eAAA,GAAA;AACE,YAAI,CAACD,iBAAL,EAAwB;AACtBA,gCAAoB,IAApB;AACAP,qBAASS,KAAT,CAAe,IAAf,EAAqBC,SAArB;AACD;AACF;AAED,aAAAC,aAAA,CAAuBC,MAAvB,EAAqC;AACnCT,oBAAYU,WAAW,YAAA;AACrBV,wBAAY,IAAZ;AACAJ,cAAEe,OAAF,EAAWR,UAAX;AACD,SAHW,EAGTM,MAHS,CAAZ;AAID;AAED,aAAAE,OAAA,CAAiBC,OAAjB,EAAqD;AAAA,0CAAfC,QAAe;AAAfA,oBAAe;AAAA;;AACnD,YAAIT,iBAAJ,EAAuB;AACrB;AACD;AACD,YAAIQ,OAAJ,EAAa;AACXP,4BAAgBC,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B;AACA;AACD;AACD,YAAIO,WAAWX,cAAcF,UAA7B;AACA,YAAIa,QAAJ,EAAc;AACZT,4BAAgBC,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B;AACA;AACD;AACD,YAAIR,cAAc,EAAlB,EAAsB;AACpB;AACAA,2BAAe,CAAf;AACD;AACD,YAAIgB,mBAAJ;AACA,YAAIb,gBAAgB,CAApB,EAAuB;AACrBA,0BAAc,CAAd;AACAa,yBAAa,CAAb;AACD,SAHD,MAGO;AACLA,yBAAa,CAAChB,cAAciB,KAAKC,MAAL,EAAf,IAAgC,IAA7C;AACD;AACDT,sBAAcO,UAAd;AACD;AACD,QAAIG,UAAU,KAAd;AAEA,aAAAvB,IAAA,CAAcwB,UAAd,EAAiC;AAC/B,YAAID,OAAJ,EAAa;AACX;AACD;AACDA,kBAAU,IAAV;AACA,YAAId,iBAAJ,EAAuB;AACrB;AACD;AACD,YAAIJ,cAAc,IAAlB,EAAwB;AACtB,gBAAI,CAACmB,UAAL,EAAiB;AACfjB,8BAAc,CAAd;AACD;AACDkB,yBAAapB,SAAb;AACAQ,0BAAc,CAAd;AACD,SAND,MAMO;AACL,gBAAI,CAACW,UAAL,EAAiB;AACfjB,8BAAc,CAAd;AACD;AACF;AACF;AACDM,kBAAc,CAAd;AACAE,eAAW,YAAA;AACTT,qBAAa,IAAb;AACAN,aAAK,IAAL;AACD,KAHD,EAGGG,OAHH;AAIA,WAAOH,IAAP;AACD;AAED;;;;;;;AAOM,SAAAA,IAAA,CAAe0B,EAAf,EAAqB;AACzBA,OAAG,KAAH;AACD","file":"backoff.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Provides a method for running a function with exponential\n * backoff.\n */\ntype id = (p1: boolean) => void;\n\nexport {id};\n\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(\n    f: (p1: (success: boolean, ...rest: any[]) => void,\n        canceled: boolean) => void,\n    callback: Function, timeout: number): id {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  let waitSeconds = 1;\n  // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n  let timeoutId: any = null;\n  let hitTimeout = false;\n  let cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n  let triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis: number): void {\n    timeoutId = setTimeout(function() {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success: boolean, ...var_args: any[]):void {\n    if (triggeredCallback) {\n      return;\n    }\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    let mustStop = canceled() || hitTimeout;\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n    let waitMillis;\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n    callWithDelay(waitMillis);\n  }\n  let stopped = false;\n\n  function stop(wasTimeout: boolean): void {\n    if (stopped) {\n      return;\n    }\n    stopped = true;\n    if (triggeredCallback) {\n      return;\n    }\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n  callWithDelay(0);\n  setTimeout(function() {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id: id) {\n  id(false);\n}\n"]}