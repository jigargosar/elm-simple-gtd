{"version":3,"sources":["src/storage/implementation/authwrapper.ts"],"names":["constants","errorsExports","promiseimpl","type","AuthWrapper","app","maker","requestMaker","service","pool","bucket_","deleted_","app_","options","isDef","extractBucket_","storageRefMaker_","requestMaker_","pool_","service_","maxOperationRetryTime_","defaultMaxOperationRetryTime","maxUploadRetryTime_","defaultMaxUploadRetryTime","requestMap_","INTERNAL","getToken","then","response","accessToken","resolve","appDeleted","loc","requestInfo","authToken","request","addRequest","clear","time","config","bucketString","configOption","makeFromBucketSpec","bucket"],"mappings":"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","file":"authwrapper.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport {Reference} from '../reference';\nimport {Service} from '../service';\nimport * as constants from './constants';\nimport * as errorsExports from './error';\nimport {errors} from './error';\nimport {FailRequest} from './failrequest';\nimport {Location} from './location';\nimport * as promiseimpl from './promise_external';\nimport {Request} from './request';\nimport {RequestInfo} from './requestinfo';\nimport {requestMaker} from './requestmaker';\nimport {RequestMap} from './requestmap';\nimport * as type from './type';\nimport {XhrIoPool} from './xhriopool';\nimport { FirebaseApp, FirebaseAuthTokenData } from \"../../app/firebase_app\";\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nexport class AuthWrapper {\n  private app_: FirebaseApp|null;\n  private bucket_: string|null = null;\n\n  /**\n  maker\n     */\n  private storageRefMaker_:\n      (p1: AuthWrapper, p2: Location) => Reference;\n  private requestMaker_: requestMaker;\n  private pool_: XhrIoPool;\n  private service_: Service;\n  private maxOperationRetryTime_: number;\n  private maxUploadRetryTime_: number;\n  private requestMap_: RequestMap;\n  private deleted_: boolean = false;\n\n  constructor(\n      app: FirebaseApp|null,\n      maker: (p1: AuthWrapper, p2: Location) => Reference,\n      requestMaker: requestMaker, service: Service,\n      pool: XhrIoPool) {\n    this.app_ = app;\n    if (this.app_ !== null) {\n      let options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  private static extractBucket_(config: {[prop: string]: any}): string|null {\n    let bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    let loc: Location = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  }\n\n  getAuthToken(): Promise<string|null> {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (this.app_ !== null && type.isDef(this.app_.INTERNAL) &&\n        type.isDef(this.app_.INTERNAL.getToken)) {\n      return this.app_.INTERNAL.getToken().then(\n          function(response: FirebaseAuthTokenData|null): string|null {\n            if (response !== null) {\n              return response.accessToken;\n            } else {\n              return null;\n            }\n          },\n          function(_error) {\n            return null;\n          });\n    } else {\n      return (promiseimpl.resolve(null) as Promise<string|null>);\n    }\n  }\n\n  bucket(): string|null {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  }\n\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  service(): Service {\n    return this.service_;\n  }\n\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  makeStorageReference(loc: Location): Reference {\n    return this.storageRefMaker_(this, loc);\n  }\n\n  makeRequest<T>(requestInfo: RequestInfo<T>, authToken: string|null): Request<T> {\n    if (!this.deleted_) {\n      let request = this.requestMaker_(\n          requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  }\n\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  deleteApp() {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  }\n\n  maxUploadRetryTime(): number {\n    return this.maxUploadRetryTime_;\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    this.maxUploadRetryTime_ = time;\n  }\n\n  maxOperationRetryTime(): number {\n    return this.maxOperationRetryTime_;\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    this.maxOperationRetryTime_ = time;\n  }\n}\n"]}