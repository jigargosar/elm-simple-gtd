"use strict";
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const File = require("vinyl");
const parse5 = require("parse5");
const polymer_bundler_1 = require("polymer-bundler");
const stream_1 = require("stream");
const file_map_url_loader_1 = require("./file-map-url-loader");
const path_transformers_1 = require("./path-transformers");
class BuildBundler extends stream_1.Transform {
    constructor(config, buildAnalyzer, options = {}) {
        super({ objectMode: true });
        // A map of urls to file objects.  As the transform stream handleds files
        // coming into the stream, it collects all files here.  After bundlling,
        // we remove files from this set that have been inlined and replace
        // entrypoint/fragment files with bundled versions.
        this.files = new Map();
        this.config = config;
        this._buildAnalyzer = buildAnalyzer;
        let { analyzer, excludes, inlineCss, inlineScripts, rewriteUrlsInTemplates, sourcemaps, stripComments, strategy, urlMapper } = options;
        const urlLoader = new file_map_url_loader_1.FileMapUrlLoader(this.files, analyzer || buildAnalyzer.analyzer);
        const forkedAnalyzer = analyzer ? analyzer._fork({ urlLoader }) :
            buildAnalyzer.analyzer._fork({ urlLoader });
        strategy = strategy ||
            this.config.shell && polymer_bundler_1.generateShellMergeStrategy(path_transformers_1.urlFromPath(this.config.root, this.config.shell));
        this._bundler = new polymer_bundler_1.Bundler({
            analyzer: forkedAnalyzer,
            excludes,
            inlineCss,
            inlineScripts,
            rewriteUrlsInTemplates,
            sourcemaps,
            stripComments,
            strategy,
            urlMapper,
        });
    }
    _buildBundles() {
        return __awaiter(this, void 0, void 0, function* () {
            // Tell the analyzer about changed files so it can purge them from its cache
            // before using the analyzer for bundling.
            yield this._bundler.analyzer.filesChanged(this._getFilesChangedSinceInitialAnalysis());
            const manifest = yield this._generateBundleManifest();
            const bundles = yield this._bundler.bundle(manifest);
            // Remove the bundled files from the file map so they are not emitted later.
            this._unmapBundledFiles(manifest);
            // Map the bundles into the file map.
            for (const [filename, document] of bundles) {
                this._mapFile(new File({
                    path: path_transformers_1.pathFromUrl(this.config.root, filename),
                    contents: new Buffer(parse5.serialize(document.ast)),
                }));
            }
        });
    }
    _flush(done) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._buildBundles();
            for (const file of this.files.values()) {
                this.push(file);
            }
            // end the stream
            done();
        });
    }
    _generateBundleManifest() {
        return __awaiter(this, void 0, void 0, function* () {
            const entrypoints = Array.from(this.config.allFragments)
                .map((e) => path_transformers_1.urlFromPath(this.config.root, e));
            return this._bundler.generateManifest(entrypoints);
        });
    }
    _getFilesChangedSinceInitialAnalysis() {
        const filesChanged = [];
        for (const [url, originalFile] of this._buildAnalyzer.files) {
            const downstreamFile = this.files.get(url);
            if (downstreamFile.contents.toString() !==
                originalFile.contents.toString()) {
                filesChanged.push(url);
            }
        }
        return filesChanged;
    }
    _mapFile(file) {
        this.files.set(path_transformers_1.urlFromPath(this.config.root, file.path), file);
    }
    _transform(file, _encoding, callback) {
        this._mapFile(file);
        callback(null, null);
    }
    _unmapBundledFiles(manifest) {
        for (const bundle of manifest.bundles.values()) {
            for (const filename of bundle.files) {
                this.files.delete(filename);
            }
        }
    }
}
exports.BuildBundler = BuildBundler;
