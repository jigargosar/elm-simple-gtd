'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = undefined;
exports.run = run;
exports.generate = generate;
exports.ask = ask;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readline = require('readline');

var _readline2 = _interopRequireDefault(_readline);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logger = exports.logger = {
  debug: function debug() {
    console.log(_chalk2.default.blue.apply(_chalk2.default, arguments));
  },
  info: function info() {
    console.log(_chalk2.default.bold.apply(_chalk2.default, arguments));
  },
  log: function log() {
    var _console;

    (_console = console).log.apply(_console, arguments);
  },
  warning: function warning() {
    console.warn(_chalk2.default.yellow.apply(_chalk2.default, arguments));
  },
  error: function error() {
    console.error(_chalk2.default.red.apply(_chalk2.default, arguments));
  }
};

var loggerAlias = logger;

function runSync(command, options) {
  try {
    var buffer = _child_process2.default.execSync(command, options);
    if (buffer) {
      return buffer.toString();
    }
    return buffer;
  } catch (error) {
    throw new _common.RunJSError(error.message);
  }
}

function runAsync(command, options) {
  return new Promise(function (resolve, reject) {
    var asyncProcess = _child_process2.default.spawn(command, options);
    var output = null;

    asyncProcess.on('error', function (error) {
      reject(new Error('Failed to start command: ' + command + '; ' + error));
    });

    asyncProcess.on('close', function (exitCode) {
      if (exitCode === 0) {
        resolve(output);
      } else {
        reject(new Error('Command failed: ' + command + ' with exit code ' + exitCode));
      }
    });

    if (options.stdio === 'pipe') {
      asyncProcess.stdout.on('data', function (buffer) {
        output = buffer.toString();
      });
    }

    if (options.timeout) {
      setTimeout(function () {
        asyncProcess.kill();
        reject(new Error('Command timeout: ' + command));
      }, options.timeout);
    }
  });
}

function run(command) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : loggerAlias;

  var binPath = _path2.default.resolve('./node_modules/.bin');

  // Pick relevant option keys and set default values
  options = {
    env: options.env || process.env,
    cwd: options.cwd,
    async: !!options.async,
    stdio: options.stdio || 'inherit',
    timeout: options.timeout,
    shell: true
  };

  // Include in PATH node_modules bin path
  options.env.PATH = [binPath, options.env.PATH || process.env.PATH].join(_path2.default.delimiter);

  logger.info(command);

  // Handle async call
  if (options.async) {
    return runAsync(command, options);
  }

  // Handle sync call by default
  return runSync(command, options);
}

function generate(src, dst, context) {
  console.log('Generating ' + dst + ' from template ' + src);
  var templateString = _fs2.default.readFileSync(src);
  var content = (0, _lodash2.default)(templateString)(context);
  _fs2.default.writeFileSync(dst, content);
}

function ask(question) {
  var readlineInterface = _readline2.default.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      try {
        readlineInterface.question(question + ' ', function (answer) {
          resolve(answer);
          readlineInterface.close();
        });
      } catch (error) {
        reject(error);
        readlineInterface.close();
      }
    }, 0);
  });
}