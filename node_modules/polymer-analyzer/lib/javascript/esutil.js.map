{"version":3,"sources":["javascript/esutil.ts"],"names":[],"mappings":"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","file":"esutil.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as estraverse from 'estraverse';\nimport * as estree from 'estree';\n\nimport {ScannedEvent, Severity, SourceRange, Warning, WarningCarryingException} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\nimport {annotateEvent} from '../polymer/docs';\n\nimport * as jsdoc from './jsdoc';\n\n/**\n * Returns whether an Espree node matches a particular object path.\n *\n * e.g. you have a MemberExpression node, and want to see whether it represents\n * `Foo.Bar.Baz`:\n *    matchesCallExpressio\n    (node, ['Foo', 'Bar', 'Baz'])\n *\n * @param {ESTree.Node} expression The Espree node to match against.\n * @param {Array<string>} path The path to look for.\n */\nexport function matchesCallExpression(\n    expression: estree.MemberExpression, path: string[]): boolean {\n  if (!expression.property || !expression.object) {\n    return false;\n  }\n  console.assert(path.length >= 2);\n\n  if (expression.property.type !== 'Identifier') {\n    return false;\n  }\n  // Unravel backwards, make sure properties match each step of the way.\n  if (expression.property.name !== path[path.length - 1]) {\n    return false;\n  }\n  // We've got ourselves a final member expression.\n  if (path.length === 2 && expression.object.type === 'Identifier') {\n    return expression.object.name === path[0];\n  }\n  // Nested expressions.\n  if (path.length > 2 && expression.object.type === 'MemberExpression') {\n    return matchesCallExpression(\n        expression.object, path.slice(0, path.length - 1));\n  }\n\n  return false;\n}\n\n/**\n * @param {Node} key The node representing an object key or expression.\n * @return {string} The name of that key.\n */\nexport function objectKeyToString(key: estree.Node): string|undefined {\n  if (key.type === 'Identifier') {\n    return key.name;\n  }\n  if (key.type === 'Literal') {\n    return '' + key.value;\n  }\n  if (key.type === 'MemberExpression') {\n    return objectKeyToString(key.object) + '.' +\n        objectKeyToString(key.property);\n  }\n  return undefined;\n}\n\nexport const CLOSURE_CONSTRUCTOR_MAP = new Map(\n    [['Boolean', 'boolean'], ['Number', 'number'], ['String', 'string']]);\n\n/**\n * AST expression -> Closure type.\n *\n * Accepts literal values, and native constructors.\n *\n * @param {Node} node An Espree expression node.\n * @return {string} The type of that expression, in Closure terms.\n */\nexport function closureType(\n    node: estree.Node,\n    sourceRange: SourceRange,\n    document: ParsedDocument<any, any>): string {\n  if (node.type.match(/Expression$/)) {\n    return node.type.substr(0, node.type.length - 10);\n  } else if (node.type === 'Literal') {\n    return typeof node.value;\n  } else if (node.type === 'Identifier') {\n    return CLOSURE_CONSTRUCTOR_MAP.get(node.name) || node.name;\n  } else {\n    throw new WarningCarryingException(new Warning({\n      code: 'no-closure-type',\n      message: `Unable to determine closure type for expression of type ` +\n          `${node.type}`,\n      severity: Severity.WARNING, sourceRange,\n      parsedDocument: document,\n    }));\n  }\n}\n\nexport function getAttachedComment(node: estree.Node): string|undefined {\n  const comments = getLeadingComments(node) || [];\n  return comments && comments[comments.length - 1];\n}\n\n/**\n * Returns all comments from a tree defined with @event.\n */\nexport function getEventComments(node: estree.Node): Map<string, ScannedEvent> {\n  const eventComments = new Set<string>();\n  estraverse.traverse(node, {\n    enter: (node: estree.Node) => {\n      (node.leadingComments || [])\n          .concat(node.trailingComments || [])\n          .map((commentAST) => commentAST.value)\n          .filter((comment) => comment.indexOf('@event') !== -1)\n          .forEach((comment) => eventComments.add(comment));\n    }\n  });\n  const events = [...eventComments]\n                     .map(\n                         (comment) => annotateEvent(jsdoc.parseJsdoc(\n                             jsdoc.removeLeadingAsterisks(comment).trim())))\n                     .filter((ev) => !!ev)\n                     .sort((ev1, ev2) => ev1.name.localeCompare(ev2.name));\n  return new Map(events.map((e) => [e.name, e] as [string, ScannedEvent]));\n}\n\nfunction getLeadingComments(node: estree.Node): string[]|undefined {\n  if (!node) {\n    return;\n  }\n  const comments = node.leadingComments;\n  return comments && comments.map((comment) => comment.value);\n}\n\nexport function getPropertyValue(\n    node: estree.ObjectExpression, name: string): estree.Node|undefined {\n  const properties = node.properties;\n  for (const property of properties) {\n    if (objectKeyToString(property.key) === name) {\n      return property.value;\n    }\n  }\n}\n\nexport function isFunctionType(node: estree.Node): node is estree.Function {\n  return node.type === 'ArrowFunctionExpression' ||\n      node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n"]}