{"version":3,"sources":["src/messaging/models/token-manager.ts"],"names":["FCM_TOKEN_DETAILS_DB","FCM_TOKEN_OBJ_STORE","FCM_TOKEN_DETAILS_DB_VERSION","TokenManager","errorFactory_","map","openDbPromise_","Promise","resolve","reject","request","indexedDB","open","onerror","event","target","error","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","keyPath","createIndex","unique","then","close","fcmToken","openDatabase_","transaction","index","get","swScope","scopeRequest","senderId","senderIdTokens","cursorRequest","openCursor","cursor","value","push","continue","subscription","pushSet","p256dh","auth","fcmSubscribeBody","endpoint","headers","Headers","append","subscribeOptions","method","body","fetch","ENDPOINT","response","json","fcmTokenResponse","message","create","codes","TOKEN_SUBSCRIBE_FAILED","TOKEN_SUBSCRIBE_NO_TOKEN","TOKEN_SUBSCRIBE_NO_PUSH_SET","masterTokenDetails","swRegistration","fcmPushSet","details","scope","put","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","length","BAD_SENDER_ID","getAllTokenDetailsForSenderId_","allTokenDetails","findIndex","tokenDetails","pushManager","getSubscription","catch","GET_SUBSCRIPTION_FAILED","isSameSubscription_","fcmTokenDetails","subscribe","SUBSCRIPTION_OPTIONS","sub","subscribeToFCM","saveTokenDetails_","token","INVALID_DELETE_TOKEN","getTokenDetailsFromToken","DELETE_TOKEN_NOT_FOUND","delete","FAILED_TO_DELETE_TOKEN"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA;;;;;;;;AAEA;;AAEA;;;;AACA;;;;AACA;;;;;;;;AAEA,IAAMA,uBAAuB,sBAA7B;AACA,IAAMC,sBAAsB,wBAA5B;AACA,IAAMC,+BAA+B,CAArC;;IAEcC,Y;AAKZ,4BAAA;AAAA;;AACE,aAAKC,aAAL,GAAqB,yBAAiB,WAAjB,EAA8B,WAA9B,EAA2C,iBAAOC,GAAlD,CAArB;AACA,aAAKC,cAAL,GAAsB,IAAtB;AACD;AAED;;;;;;;;;wCAKa;AACX,gBAAI,KAAKA,cAAT,EAAyB;AACvB,uBAAO,KAAKA,cAAZ;AACD;AAED,iBAAKA,cAAL,GAAsB,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AAChD,oBAAMC,UAAUC,UAAUC,IAAV,CAAeZ,oBAAf,EACdE,4BADc,CAAhB;AAEAQ,wBAAQG,OAAR,GAAkB,iBAAK;AACrBJ,2BAAqBK,MAAMC,MAAN,CAAcC,KAAnC;AACD,iBAFD;AAGAN,wBAAQO,SAAR,GAAoB,iBAAK;AACvBT,4BAAsBM,MAAMC,MAAN,CAAcG,MAApC;AACD,iBAFD;AAGAR,wBAAQS,eAAR,GAA0B,iBAAK;AAC7B,wBAAIC,KAAmBN,MAAMC,MAAN,CAAcG,MAArC;AAEA,wBAAIG,cAAcD,GAAGE,iBAAH,CAAqBrB,mBAArB,EAA0C;AAC1DsB,iCAAS;AADiD,qBAA1C,CAAlB;AAIA;AACAF,gCAAYG,WAAZ,CAAwB,aAAxB,EAAuC,aAAvC,EAAsD;AACpDC,gCAAQ;AAD4C,qBAAtD;AAIAJ,gCAAYG,WAAZ,CAAwB,UAAxB,EAAoC,UAApC,EAAgD;AAC9CC,gCAAQ;AADsC,qBAAhD;AAGD,iBAfD;AAgBD,aAzBqB,CAAtB;AA2BA,mBAAO,KAAKnB,cAAZ;AACD;AAED;;;;;;;wCAIa;AAAA;;AACX,gBAAI,KAAKA,cAAT,EAAyB;AACvB,uBAAO,KAAKA,cAAL,CAAoBoB,IAApB,CAAyB,cAAE;AAChCN,uBAAGO,KAAH;AACA,0BAAKrB,cAAL,GAAsB,IAAtB;AACD,iBAHM,CAAP;AAID;AAED,mBAAOC,QAAQC,OAAR,EAAP;AACD;AAED;;;;;;;;;iDAMyBoB,Q,EAAQ;AAC/B,mBAAO,KAAKC,aAAL,GACNH,IADM,CACD,cAAE;AACN,uBAAO,IAAInB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AACjC,wBAAMqB,cAAcV,GAAGU,WAAH,CAAe,CAAC7B,mBAAD,CAAf,CAApB;AACA,wBAAMoB,cAAcS,YAAYT,WAAZ,CAAwBpB,mBAAxB,CAApB;AACA,wBAAM8B,QAAQV,YAAYU,KAAZ,CAAkB,UAAlB,CAAd;AACA,wBAAMrB,UAAUqB,MAAMC,GAAN,CAAUJ,QAAV,CAAhB;AACAlB,4BAAQG,OAAR,GAAkB,UAASC,KAAT,EAAc;AAC9BL,+BAAqBK,MAAMC,MAAN,CAAcC,KAAnC;AACD,qBAFD;AAGAN,4BAAQO,SAAR,GAAoB,UAASH,KAAT,EAAc;AAChCN,gCAAsBM,MAAMC,MAAN,CAAcG,MAApC;AACD,qBAFD;AAGD,iBAXM,CAAP;AAYD,aAdM,CAAP;AAeD;;;oDAE2Be,O,EAAO;AACjC,mBAAO,KAAKJ,aAAL,GACNH,IADM,CACD,cAAE;AACN,uBAAO,IAAInB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AACjC,wBAAMqB,cAAcV,GAAGU,WAAH,CAAe,CAAC7B,mBAAD,CAAf,CAApB;AACA,wBAAMoB,cAAcS,YAAYT,WAAZ,CAAwBpB,mBAAxB,CAApB;AACA,wBAAMiC,eAAeb,YAAYW,GAAZ,CAAgBC,OAAhB,CAArB;AACAC,iCAAarB,OAAb,GAAuB,iBAAK;AAC1BJ,+BAAqBK,MAAMC,MAAN,CAAcC,KAAnC;AACD,qBAFD;AAIAkB,iCAAajB,SAAb,GAAyB,iBAAK;AAC5BT,gCAAsBM,MAAMC,MAAN,CAAcG,MAApC;AACD,qBAFD;AAGD,iBAXM,CAAP;AAYD,aAdM,CAAP;AAeD;;;uDAE8BiB,Q,EAAQ;AACrC,mBAAO,KAAKN,aAAL,GACNH,IADM,CACD,cAAE;AACN,uBAAO,IAAInB,OAAJ,CAA2B,UAACC,OAAD,EAAUC,MAAV,EAAgB;AAChD,wBAAMqB,cAAcV,GAAGU,WAAH,CAAe,CAAC7B,mBAAD,CAAf,CAApB;AACA,wBAAMoB,cAAcS,YAAYT,WAAZ,CAAwBpB,mBAAxB,CAApB;AAEA,wBAAMmC,iBAAiB,EAAvB;AAEA,wBAAMC,gBAAgBhB,YAAYiB,UAAZ,EAAtB;AACAD,kCAAcxB,OAAd,GAAwB,iBAAK;AAC3BJ,+BAAqBK,MAAMC,MAAN,CAAcC,KAAnC;AACD,qBAFD;AAIAqB,kCAAcpB,SAAd,GAA0B,iBAAK;AAC7B,4BAAMsB,SAAuBzB,MAAMC,MAAN,CAAcG,MAA3C;AACA,4BAAIqB,MAAJ,EAAY;AACV,gCAAIA,OAAOC,KAAP,CAAa,aAAb,MAAgCL,QAApC,EAA8C;AAC5CC,+CAAeK,IAAf,CAAoBF,OAAOC,KAA3B;AACD;AACDD,mCAAOG,QAAP;AACD,yBALD,MAKO;AACLlC,oCAAQ4B,cAAR;AACD;AACF,qBAVD;AAWD,iBAtBM,CAAP;AAuBD,aAzBM,CAAP;AA0BD;AAED;;;;;;;;;;;;;uCAUeD,Q,EAAUQ,Y,EAAcC,O,EAAQ;AAAA;;AAC7C,gBAAMC,SAAS,iCAAoBF,aAAa,QAAb,EAAuB,QAAvB,CAApB,CAAf;AACA,gBAAMG,OAAO,iCAAoBH,aAAa,QAAb,EAAuB,MAAvB,CAApB,CAAb;AAEA,gBAAII,mBAAmB,uBAAqBZ,QAArB,wBACTQ,aAAaK,QADJ,+BAEHH,MAFG,gCAGFC,IAHE,CAAvB;AAKA,gBAAIF,OAAJ,EAAa;AACXG,kDAAgCH,OAAhC;AACD;AAED,gBAAMK,UAAU,IAAIC,OAAJ,EAAhB;AACAD,oBAAQE,MAAR,CAAe,cAAf,EAA+B,mCAA/B;AAEA,gBAAMC,mBAAmB;AACvBC,wBAAQ,MADe;AAEvBJ,yBAASA,OAFc;AAGvBK,sBAAMP;AAHiB,aAAzB;AAMA,mBAAOQ,MAAM,qBAAWC,QAAX,GAAsB,wBAA5B,EACLJ,gBADK,EAEN1B,IAFM,CAED;AAAA,uBAAY+B,SAASC,IAAT,EAAZ;AAAA,aAFC,EAGNhC,IAHM,CAGD,oBAAQ;AACZ,oBAAMiC,mBAAmBF,QAAzB;AACA,oBAAIE,iBAAiB,OAAjB,CAAJ,EAA+B;AAC7B,wBAAMC,UAAUD,iBAAiB,OAAjB,EAA0B,SAA1B,CAAhB;AACA,0BAAM,OAAKvD,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAaC,sBAAvC,EACJ,EAAC,WAAWH,OAAZ,EADI,CAAN;AAED;AAED,oBAAI,CAACD,iBAAiB,OAAjB,CAAL,EAAgC;AAC9B,0BAAM,OAAKvD,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAaE,wBAAvC,CAAN;AACD;AAED,oBAAI,CAACL,iBAAiB,SAAjB,CAAL,EAAkC;AAChC,0BAAM,OAAKvD,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAaG,2BAAvC,CAAN;AACD;AAED,uBAAO;AACL,6BAASN,iBAAiB,OAAjB,CADJ;AAEL,+BAAWA,iBAAiB,SAAjB;AAFN,iBAAP;AAID,aAvBM,CAAP;AAwBD;AAED;;;;;;;;;;;;;;4CAWoBhB,Y,EAAcuB,kB,EAAkB;AAClD;AACA;AACA,mBAAQvB,aAAaK,QAAb,KAA0BkB,mBAAmB,UAAnB,CAA1B,IACN,iCAAoBvB,aAAa,QAAb,EAAuB,MAAvB,CAApB,MACEuB,mBAAmB,MAAnB,CAFI,IAGN,iCAAoBvB,aAAa,QAAb,EAAuB,QAAvB,CAApB,MACEuB,mBAAmB,QAAnB,CAJJ;AAKD;AAED;;;;;;;;;;;;;;;;0CAakB/B,Q,EAAUgC,c,EAC1BxB,Y,EAAcf,Q,EAAUwC,U,EAAU;AAClC,gBAAMC,UAAU;AACd,2BAAWF,eAAeG,KADZ;AAEd,4BAAY3B,aAAaK,QAFX;AAGd,wBAAQ,iCAAoBL,aAAa,QAAb,EAAuB,MAAvB,CAApB,CAHM;AAId,0BAAU,iCAAoBA,aAAa,QAAb,EAAuB,QAAvB,CAApB,CAJI;AAKd,4BAAYf,QALE;AAMd,8BAAcwC,UANA;AAOd,+BAAejC;AAPD,aAAhB;AAUA,mBAAO,KAAKN,aAAL,GACNH,IADM,CACD,cAAE;AACN,uBAAO,IAAInB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AACjC,wBAAMqB,cAAcV,GAAGU,WAAH,CAAe,CAAC7B,mBAAD,CAAf,EAAsC,WAAtC,CAApB;AACA,wBAAMoB,cAAcS,YAAYT,WAAZ,CAAwBpB,mBAAxB,CAApB;AACA,wBAAMS,UAAUW,YAAYkD,GAAZ,CAAgBF,OAAhB,CAAhB;AACA3D,4BAAQG,OAAR,GAAkB,iBAAK;AACrBJ,+BAAqBK,MAAMC,MAAN,CAAcC,KAAnC;AACD,qBAFD;AAGAN,4BAAQO,SAAR,GAAoB,YAAK;AACvBT;AACD,qBAFD;AAGD,iBAVM,CAAP;AAWD,aAbM,CAAP;AAcD;AAED;;;;;;;;;;;;;;sCAWc2B,Q,EAAUgC,c,EAAc;AAAA;;AACpC,gBAAI,EAAEA,0BAA0BK,yBAA5B,CAAJ,EAA4D;AAC1D,uBAAOjE,QAAQE,MAAR,CAAe,KAAKL,aAAL,CAAmByD,MAAnB,CACpB,iBAAOC,KAAP,CAAaW,wBADO,CAAf,CAAP;AAED;AAED,gBAAI,OAAOtC,QAAP,KAAoB,QAApB,IAAgCA,SAASuC,MAAT,KAAoB,CAAxD,EAA2D;AACzD,uBAAOnE,QAAQE,MAAR,CAAe,KAAKL,aAAL,CAAmByD,MAAnB,CACpB,iBAAOC,KAAP,CAAaa,aADO,CAAf,CAAP;AAED;AAED,mBAAO,KAAKC,8BAAL,CAAoCzC,QAApC,EACNT,IADM,CACD,2BAAe;AACnB,oBAAImD,gBAAgBH,MAAhB,KAA2B,CAA/B,EAAkC;AAChC;AACD;AAED,oBAAM3C,QAAQ8C,gBAAgBC,SAAhB,CAA0B,wBAAY;AAClD,2BAAQX,eAAeG,KAAf,KAAyBS,aAAa,SAAb,CAAzB,IACN5C,aAAa4C,aAAa,aAAb,CADf;AAED,iBAHa,CAAd;AAKA,oBAAIhD,UAAU,CAAC,CAAf,EAAkB;AAChB;AACD;AAED,uBAAO8C,gBAAgB9C,KAAhB,CAAP;AACD,aAhBM,EAiBNL,IAjBM,CAiBD,wBAAY;AAChB,oBAAI,CAACqD,YAAL,EAAmB;AACjB;AACD;AAED,uBAAOZ,eAAea,WAAf,CAA2BC,eAA3B,GACNC,KADM,CACA,YAAG;AACR,0BAAM,OAAK9E,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAaqB,uBAAvC,CAAN;AACD,iBAHM,EAINzD,IAJM,CAID,wBAAY;AAChB,wBAAIiB,gBACF,OAAKyC,mBAAL,CAAyBzC,YAAzB,EAAuCoC,YAAvC,CADF,EACwD;AACtD,+BAAOA,aAAa,UAAb,CAAP;AACD;AACF,iBATM,CAAP;AAUD,aAhCM,CAAP;AAiCD;AAED;;;;;;oCAGY5C,Q,EAAUgC,c,EAAc;AAAA;;AAClC,gBAAI,OAAOhC,QAAP,KAAoB,QAApB,IAAgCA,SAASuC,MAAT,KAAoB,CAAxD,EAA2D;AACzD,uBAAOnE,QAAQE,MAAR,CAAe,KAAKL,aAAL,CAAmByD,MAAnB,CACpB,iBAAOC,KAAP,CAAaa,aADO,CAAf,CAAP;AAED;AAED,gBAAI,EAAER,0BAA2BK,yBAA7B,CAAJ,EAA6D;AAC3D,uBAAOjE,QAAQE,MAAR,CAAe,KAAKL,aAAL,CAAmByD,MAAnB,CACpB,iBAAOC,KAAP,CAAaW,wBADO,CAAf,CAAP;AAED;AAED;AACA,gBAAI9B,qBAAJ;AACA,gBAAI0C,wBAAJ;AACA,mBAAOlB,eAAea,WAAf,CAA2BC,eAA3B,GACNvD,IADM,CACD,wBAAY;AAChB,oBAAIiB,YAAJ,EAAkB;AAChB,2BAAOA,YAAP;AACD;AAED,uBAAOwB,eAAea,WAAf,CAA2BM,SAA3B,CACL,qBAAWC,oBADN,CAAP;AAED,aARM,EASN7D,IATM,CASD,eAAG;AACPiB,+BAAe6C,GAAf;AACA,uBAAO,OAAKC,cAAL,CAAoBtD,QAApB,EAA8BQ,YAA9B,CAAP;AACD,aAZM,EAaNjB,IAbM,CAaD,wBAAY;AAChB2D,kCAAkBN,YAAlB;AACA,uBAAO,OAAKW,iBAAL,CAAuBvD,QAAvB,EAAiCgC,cAAjC,EAAiDxB,YAAjD,EACH0C,gBAAgB,OAAhB,CADG,EACuBA,gBAAgB,SAAhB,CADvB,CAAP;AAED,aAjBM,EAkBN3D,IAlBM,CAkBD;AAAA,uBAAM2D,gBAAgB,OAAhB,CAAN;AAAA,aAlBC,CAAP;AAmBD;AAED;;;;;;;;;;;oCAQYM,K,EAAK;AAAA;;AACf,gBAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,MAAMjB,MAAN,KAAiB,CAAlD,EAAqD;AACnD,uBAAOnE,QAAQE,MAAR,CACL,KAAKL,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAa8B,oBAAvC,CADK,CAAP;AAED;AAED,mBAAO,KAAKC,wBAAL,CAA8BF,KAA9B,EACNjE,IADM,CACD,mBAAO;AACX,oBAAI,CAAC2C,OAAL,EAAc;AACZ,0BAAM,OAAKjE,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAagC,sBAAvC,CAAN;AACD;AAED,uBAAQ,OAAKjE,aAAL,GACPH,IADO,CACF,cAAE;AACN,2BAAO,IAAInB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AACjC,4BAAMqB,cAAcV,GAAGU,WAAH,CAAe,CAAC7B,mBAAD,CAAf,EAChB,WADgB,CAApB;AAEA,4BAAMoB,cAAcS,YAAYT,WAAZ,CAAwBpB,mBAAxB,CAApB;AACA,4BAAMS,UAAUW,YAAY0E,MAAZ,CAAmB1B,QAAQ,SAAR,CAAnB,CAAhB;AACA3D,gCAAQG,OAAR,GAAkB,iBAAK;AACrBJ,mCAAqBK,MAAMC,MAAN,CAAcC,KAAnC;AACD,yBAFD;AAGAN,gCAAQO,SAAR,GAAoB,iBAAK;AACvB,gCAAkBH,MAAMC,MAAN,CAAcG,MAAd,KAAyB,CAA3C,EAA8C;AAC5CT,uCAAO,OAAKL,aAAL,CAAmByD,MAAnB,CAA0B,iBAAOC,KAAP,CAAakC,sBAAvC,CAAP;AACA;AACD;AAEDxF,oCAAQ6D,OAAR;AACD,yBAPD;AAQD,qBAhBM,CAAP;AAiBD,iBAnBO,CAAR;AAoBD,aA1BM,CAAP;AA2BD;;;;;;kBAxYWlE,Y","file":"token-manager.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport {ErrorFactory} from '../../app/errors';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(FCM_TOKEN_DETAILS_DB,\n        FCM_TOKEN_DETAILS_DB_VERSION);\n      request.onerror = event => {\n        reject((<IDBRequest> event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest> event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest> event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest> event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest> event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest> event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest> event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest> event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest> event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody = `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions)\n    .then(response => response.json())\n    .then(response => {\n      const fcmTokenResponse = response;\n      if (fcmTokenResponse['error']) {\n        const message = fcmTokenResponse['error']['message'];\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED,\n          {'message': message});\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n\n      if (!fcmTokenResponse['pushSet']) {\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n\n      return {\n        'token': fcmTokenResponse['token'],\n        'pushSet': fcmTokenResponse['pushSet']\n      };\n    });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']);\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(senderId, swRegistration,\n    subscription, fcmToken, fcmPushSet) {\n    const details = {\n      'swScope': swRegistration.scope,\n      'endpoint': subscription.endpoint,\n      'auth': arrayBufferToBase64(subscription['getKey']('auth')),\n      'p256dh': arrayBufferToBase64(subscription['getKey']('p256dh')),\n      'fcmToken': fcmToken,\n      'fcmPushSet': fcmPushSet,\n      'fcmSenderId': senderId\n    };\n\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest> event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.BAD_SENDER_ID));\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n    .then(allTokenDetails => {\n      if (allTokenDetails.length === 0) {\n        return;\n      }\n\n      const index = allTokenDetails.findIndex(tokenDetails => {\n        return (swRegistration.scope === tokenDetails['swScope'] &&\n          senderId === tokenDetails['fcmSenderId']);\n      });\n\n      if (index === -1) {\n        return;\n      }\n\n      return allTokenDetails[index];\n    })\n    .then(tokenDetails => {\n      if (!tokenDetails) {\n        return;\n      }\n\n      return swRegistration.pushManager.getSubscription()\n      .catch(err => {\n        throw this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n      })\n      .then(subscription => {\n        if (subscription &&\n          this.isSameSubscription_(subscription, tokenDetails)) {\n          return tokenDetails['fcmToken'];\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.BAD_SENDER_ID));\n    }\n\n    if (!(swRegistration  instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager.getSubscription()\n    .then(subscription => {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe(\n        FCMDetails.SUBSCRIPTION_OPTIONS);\n    })\n    .then(sub => {\n      subscription = sub;\n      return this.subscribeToFCM(senderId, subscription)\n    })\n    .then(tokenDetails => {\n      fcmTokenDetails = tokenDetails;\n      return this.saveTokenDetails_(senderId, swRegistration, subscription,\n          fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n    })\n    .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n    }\n\n    return this.getTokenDetailsFromToken(token)\n    .then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return  this.openDatabase_()\n      .then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction([FCM_TOKEN_OBJ_STORE],\n              'readwrite');\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest> event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest> event.target).result === 0) {\n              reject(this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n"]}