{"version":3,"sources":["test/polymer/expression-scanner_test.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;AAEH,+BAA4B;AAG5B,wDAAkD;AAClD,0EAAoE;AACpE,yEAA6K;AAC7K,8CAA6C;AAE7C,KAAK,CAAC,mBAAmB,EAAE;IAEzB,KAAK,CAAC,+BAA+B,EAAE;QACrC,IAAI,CAAC,mCAAmC,EAAE;YACxC,MAAM,QAAQ,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;OAyBhB,CAAC;YACF,MAAM,UAAU,GAAG,2BAAc,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YACrE,MAAM,QAAQ,GAAG,IAAI,wBAAU,EAAE,CAAC,KAAK,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;YAE/D,MAAM,OAAO,GAAG,MAAM,+CAA0B,CAAC,QAAQ,CAAC,CAAC;YAC3D,MAAM,kBAAkB,GAAG,OAAO,CAAC,WAAW,CAAC;YAE/C,aAAM,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YACvC,aAAM,CAAC,SAAS,CACZ,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,eAAe,CAAC,EAChD,CAAC,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;YACvE,MAAM,WAAW,GACb,kBAAsD,CAAC;YAC3D,aAAM,CAAC,SAAS,CACZ,MAAM,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,EAAE;gBACjE;;2BAEe;gBACf;;yCAE6B;gBAC7B;;sDAE0C;gBAC1C;;6BAEiB;gBACjB;;yBAEa;aACd,CAAC,CAAC;YACP,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YACpE,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,EACxC,CAAC,KAAK,EAAE,KAAK,EAAE,gCAAgC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;YACpE,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,EACnC,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;YAC7D,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,EACvD,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YACvC,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,EACvD,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACpE,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;YAC9D,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,iBAAiB,CAAC,EAC3C,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;QACtC,CAAC,CAAA,CAAC,CAAC;QAEH,IAAI,CAAC,0CAA0C,EAAE;YAC/C,MAAM,QAAQ,GAAG;;;;;;;;;;;;OAYhB,CAAC;YACF,MAAM,UAAU,GAAG,2BAAc,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YACrE,MAAM,QAAQ,GAAG,IAAI,wBAAU,EAAE,CAAC,KAAK,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;YAE/D,MAAM,OAAO,GAAG,MAAM,+CAA0B,CAAC,QAAQ,CAAC,CAAC;YAC3D,MAAM,kBAAkB,GAAG,OAAO,CAAC,WAAW,CAAC;YAE/C,aAAM,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YACvC,aAAM,CAAC,SAAS,CACZ,MAAM,UAAU,CAAC,SAAS,CACtB,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,EACjD;gBACE;;0BAEc;gBACd;;6BAEiB;gBACjB;;wBAEY;gBACZ;;6BAEiB;aAClB,CAAC,CAAC;YACP,MAAM,WAAW,GACb,kBAAsD,CAAC;YAC3D,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,iBAAiB,CAAC,EAC3C,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;YAClC,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YAC/D,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YACxE,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,EACvD,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACtC,aAAM,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;YACvE,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,EACnC,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;YAClD,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,EACvD,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YAC9B,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,eAAe,CAAC,EACzC,CAAC,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;QAC5D,CAAC,CAAA,CAAC,CAAC;QAEH,IAAI,CAAC,iCAAiC,EAAE;YACtC,MAAM,QAAQ,GAAG;;;;;;;;;;;;;;;;;OAiBhB,CAAC;YAEF,MAAM,UAAU,GAAG,2BAAc,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YACrE,MAAM,QAAQ,GAAG,IAAI,wBAAU,EAAE,CAAC,KAAK,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;YAE/D,MAAM,OAAO,GAAG,MAAM,+CAA0B,CAAC,QAAQ,CAAC,CAAC;YAC3D,MAAM,kBAAkB,GAAG,OAAO,CAAC,WAAW,CAAC;YAE/C,aAAM,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YACvC,aAAM,CAAC,SAAS,CACZ,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,eAAe,CAAC,EAChD,CAAC,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;YACvE,MAAM,WAAW,GAAG,kBAAqD,CAAC;YAC1E,aAAM,CAAC,SAAS,CACZ,MAAM,UAAU,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,EAAE;gBACjE;;qBAES;gBACT;;kBAEM;gBACN;;4BAEgB;gBAChB;;mCAEuB;gBACvB;;;;;;;;;;aAUC;aACF,CAAC,CAAC;YACP,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YACpE,aAAM,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,EAAE;gBACzD,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL;;;;aAIK;aACN,CAAC,CAAC;YACH,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,EACvD,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;YACxE,aAAM,CAAC,SAAS,CACZ,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QAChE,CAAC,CAAA,CAAC,CAAC;QAEH,IAAI,CAAC,2CAA2C,EAAE;YAChD,MAAM,QAAQ,GAAG;;;;;;;;;;;;;;;;OAgBhB,CAAC;YAEF,MAAM,UAAU,GAAG,2BAAc,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YACrE,MAAM,QAAQ,GAAG,IAAI,wBAAU,EAAE,CAAC,KAAK,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;YAE/D,MAAM,OAAO,GAAG,MAAM,+CAA0B,CAAC,QAAQ,CAAC,CAAC;YAC3D,aAAM,CAAC,SAAS,CACZ,MAAM,UAAU,CAAC,SAAS,CACtB,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,EAC/C;gBACE;;2BAEe;gBACf;;kBAEM;gBACN;;cAEE;gBACF;;0BAEc;gBACd;;qBAES;gBACT;;gCAEoB;aACrB,CAAC,CAAC;QACT,CAAC,CAAA,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,KAAK,CAAC,qDAAqD,EAAE;QAC3D,IAAI,CAAC,gCAAgC,EAAE;YACrC,MAAM,QAAQ,GAAG;;;;;;;;OAQhB,CAAC;YACF,MAAM,UAAU,GAAG,2BAAc,CAAC,WAAW,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;YACnE,MAAM,kBAAkB,GACpB,IAAI,oCAAgB,EAAE,CAAC,KAAK,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YACtD,MAAM,QAAQ,GACT,kBAAkB,CAAC,GAAW;iBAC1B,IAAI,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC;YAExD,MAAM,cAAc,GAAG,QAAQ,CAAC,GAAG,CAC/B,CAAC,CAAC,KACE,qDAAgC,CAAC,kBAAkB,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;YACzE,MAAM,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,QAAQ,CAAC;iBAClC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACxD,MAAM,gBAAgB,GAAG,cAAc,CAAC,GAAG,CACvC,CAAC,EAAE,KAAK,EAAE,CAAC,WAAW,IAAI,EAAE,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YAC1D,aAAM,CAAC,SAAS,CAAC,MAAM,UAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,EAAE;gBAC7D;;yBAEiB;gBACjB,wBAAwB;gBACxB,wBAAwB;gBACxB,wBAAwB;gBACxB,wBAAwB;aACzB,CAAC,CAAC;YACH,aAAM,CAAC,SAAS,CAAC,MAAM,UAAU,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE;gBACrD;;qBAEa;gBACb;;aAEK;gBACL;;oCAE4B;aAC7B,CAAC,CAAC;QACL,CAAC,CAAA,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","file":"expression-scanner_test.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {assert} from 'chai';\nimport * as estree from 'estree';\n\nimport {HtmlParser} from '../../html/html-parser';\nimport {JavaScriptParser} from '../../javascript/javascript-parser';\nimport {AttributeDatabindingExpression, parseExpressionInJsStringLiteral, scanDocumentForExpressions, TextNodeDatabindingExpression} from '../../polymer/expression-scanner';\nimport {CodeUnderliner} from '../test-utils';\n\nsuite('ExpressionScanner', () => {\n\n  suite('scanning html for expressions', () => {\n    test('finds whole-attribute expressions', async() => {\n      const contents = `\n        <dom-module id=\"foo-elem\">\n          <template>\n            <div id=\"{{foo}}\"></div>\n            <input value=\"{{val::changed}}\">\n            <template is=\"dom-if\">\n              <div id=\"[[bar]]\"></div>\n            </template>\n            <div id=\"{{bada(wing, daba.boom, 10, -20)}}\"></div>\n          </template>\n          <script>\n            Polymer({\n              is: 'foo-elem',\n            });\n          </script>\n        </dom-module>\n\n        <div id=\"{{nope}}\"></div>\n        <template>\n          <div id=\"{{notHereEither}}\"></div>\n        </template>\n\n        <template is=\"dom-bind\">\n          <div id=\"{{baz}}\"></div>\n        </template>\n      `;\n      const underliner = CodeUnderliner.withMapping('test.html', contents);\n      const document = new HtmlParser().parse(contents, 'test.html');\n\n      const results = await scanDocumentForExpressions(document);\n      const generalExpressions = results.expressions;\n\n      assert.deepEqual(results.warnings, []);\n      assert.deepEqual(\n          generalExpressions.map((e) => e.databindingInto),\n          ['attribute', 'attribute', 'attribute', 'attribute', 'attribute']);\n      const expressions =\n          generalExpressions as AttributeDatabindingExpression[];\n      assert.deepEqual(\n          await underliner.underline(expressions.map((e) => e.sourceRange)), [\n            `\n            <div id=\"{{foo}}\"></div>\n                       ~~~`,\n            `\n            <input value=\"{{val::changed}}\">\n                            ~~~~~~~~~~~~`,\n            `\n            <div id=\"{{bada(wing, daba.boom, 10, -20)}}\"></div>\n                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`,\n            `\n              <div id=\"[[bar]]\"></div>\n                         ~~~`,\n            `\n          <div id=\"{{baz}}\"></div>\n                     ~~~`,\n          ]);\n      assert.deepEqual(\n          expressions.map((e) => e.direction), ['{', '{', '{', '[', '{']);\n      assert.deepEqual(\n          expressions.map((e) => e.expressionText),\n          ['foo', 'val', 'bada(wing, daba.boom, 10, -20)', 'bar', 'baz']);\n      assert.deepEqual(\n          expressions.map((e) => e.eventName),\n          [undefined, 'changed', undefined, undefined, undefined]);\n      assert.deepEqual(\n          expressions.map((e) => e.attribute && e.attribute.name),\n          ['id', 'value', 'id', 'id', 'id']);\n      assert.deepEqual(\n          expressions.map((e) => e.properties.map((p) => p.name)),\n          [['foo'], ['val'], ['bada', 'wing', 'daba'], ['bar'], ['baz']]);\n      assert.deepEqual(\n          expressions.map((e) => e.warnings), [[], [], [], [], []]);\n      assert.deepEqual(\n          expressions.map((e) => e.isCompleteBinding),\n          [true, true, true, true, true]);\n    });\n\n    test('finds interpolated attribute expressions', async() => {\n      const contents = `\n        <template is=\"dom-bind\">\n          <div id=\" {{foo}}\"></div>\n          <div id=\"bar {{val}} baz\">\n          <div id=\" [[x]]{{y}}\"></div>\n        </template>\n\n        <div id=\" {{nope}}\"></div>\n        <template>\n          <div id=\"{{notHereEither}}\"></div>\n        </template>\n\n      `;\n      const underliner = CodeUnderliner.withMapping('test.html', contents);\n      const document = new HtmlParser().parse(contents, 'test.html');\n\n      const results = await scanDocumentForExpressions(document);\n      const generalExpressions = results.expressions;\n\n      assert.deepEqual(results.warnings, []);\n      assert.deepEqual(\n          await underliner.underline(\n              generalExpressions.map((e) => e.sourceRange)),\n          [\n            `\n          <div id=\" {{foo}}\"></div>\n                      ~~~`,\n            `\n          <div id=\"bar {{val}} baz\">\n                         ~~~`,\n            `\n          <div id=\" [[x]]{{y}}\"></div>\n                      ~`,\n            `\n          <div id=\" [[x]]{{y}}\"></div>\n                           ~`\n          ]);\n      const expressions =\n          generalExpressions as AttributeDatabindingExpression[];\n      assert.deepEqual(\n          expressions.map((e) => e.isCompleteBinding),\n          [false, false, false, false]);\n      assert.deepEqual(\n          expressions.map((e) => e.direction), ['{', '{', '[', '{']);\n      assert.deepEqual(\n          expressions.map((e) => e.expressionText), ['foo', 'val', 'x', 'y']);\n      assert.deepEqual(\n          expressions.map((e) => e.properties.map((p) => p.name)),\n          [['foo'], ['val'], ['x'], ['y']]);\n      assert.deepEqual(expressions.map((e) => e.warnings), [[], [], [], []]);\n      assert.deepEqual(\n          expressions.map((e) => e.eventName),\n          [undefined, undefined, undefined, undefined]);\n      assert.deepEqual(\n          expressions.map((e) => e.attribute && e.attribute.name),\n          ['id', 'id', 'id', 'id']);\n      assert.deepEqual(\n          expressions.map((e) => e.databindingInto),\n          ['attribute', 'attribute', 'attribute', 'attribute']);\n    });\n\n    test('finds expressions in text nodes', async() => {\n      const contents = `\n        <template is=\"dom-bind\">\n          <div>{{foo}}</div>\n          <div>\n            {{bar}} + {{baz}}[[zod]]\n            {{\n              multiline(\n                expressions\n              )\n            }}\n          </div>\n        </template>\n\n        {{nope}}\n        <template>\n          <div id=\"{{notHereEither}}\"></div>\n        </template>\n      `;\n\n      const underliner = CodeUnderliner.withMapping('test.html', contents);\n      const document = new HtmlParser().parse(contents, 'test.html');\n\n      const results = await scanDocumentForExpressions(document);\n      const generalExpressions = results.expressions;\n\n      assert.deepEqual(results.warnings, []);\n      assert.deepEqual(\n          generalExpressions.map((e) => e.databindingInto),\n          ['text-node', 'text-node', 'text-node', 'text-node', 'text-node']);\n      const expressions = generalExpressions as TextNodeDatabindingExpression[];\n      assert.deepEqual(\n          await underliner.underline(expressions.map((e) => e.sourceRange)), [\n            `\n          <div>{{foo}}</div>\n                 ~~~`,\n            `\n            {{bar}} + {{baz}}[[zod]]\n              ~~~`,\n            `\n            {{bar}} + {{baz}}[[zod]]\n                        ~~~`,\n            `\n            {{bar}} + {{baz}}[[zod]]\n                               ~~~`,\n            `\n            {{\n              ~\n              multiline(\n~~~~~~~~~~~~~~~~~~~~~~~~\n                expressions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n              )\n~~~~~~~~~~~~~~~\n            }}\n~~~~~~~~~~~~`\n          ]);\n      assert.deepEqual(\n          expressions.map((e) => e.direction), ['{', '{', '{', '[', '{']);\n      assert.deepEqual(expressions.map((e) => e.expressionText), [\n        'foo',\n        'bar',\n        'baz',\n        'zod',\n        `\n              multiline(\n                expressions\n              )\n            `\n      ]);\n      assert.deepEqual(\n          expressions.map((e) => e.properties.map((p) => p.name)),\n          [['foo'], ['bar'], ['baz'], ['zod'], ['multiline', 'expressions']]);\n      assert.deepEqual(\n          expressions.map((e) => e.warnings), [[], [], [], [], []]);\n    });\n\n    test('gives accurate locations for parse errors', async() => {\n      const contents = `\n        <template is=\"dom-bind\">\n          <div id=\"{{foo(}}\"></div>\n          <div id='[[\n            foo bar\n          ]]'></div>\n          {{]}}\n\n          <!-- ignores expressions that are invalid JS -->\n          <div id=\"{{foo(bar.*)}}\"></div>\n          <div id=\"{{foo(bar.0)}}\"></div>\n\n          <!-- finds warnings in valid JS but invalid Polymer expressions -->\n          <div id=\"{{-foo}}\"></div>\n          {{foo(!bar, () => baz)}}\n        </template>\n      `;\n\n      const underliner = CodeUnderliner.withMapping('test.html', contents);\n      const document = new HtmlParser().parse(contents, 'test.html');\n\n      const results = await scanDocumentForExpressions(document);\n      assert.deepEqual(\n          await underliner.underline(\n              results.warnings.map((w) => w.sourceRange)),\n          [\n            `\n          <div id=\"{{foo(}}\"></div>\n                         ~`,\n            `\n            foo bar\n                ~`,\n            `\n          {{]}}\n            ~`,\n            `\n          <div id=\"{{-foo}}\"></div>\n                     ~~~~`,\n            `\n          {{foo(!bar, () => baz)}}\n                ~~~~`,\n            `\n          {{foo(!bar, () => baz)}}\n                      ~~~~~~~~~`\n          ]);\n    });\n  });\n\n  suite('parsing expressions from javascript string literals', () => {\n    test('it succeeds and fails properly', async() => {\n      const contents = `\n        const observers = [\n          'foo(bar, baz)',\n          'foo(bar baz)',\n          'foo(bar.*)',\n          10,\n          observerAssignedElsewhere,\n        ];\n      `;\n      const underliner = CodeUnderliner.withMapping('test.js', contents);\n      const javascriptDocument =\n          new JavaScriptParser().parse(contents, 'test.js');\n      const literals: estree.Literal[] =\n          (javascriptDocument.ast as any)\n              .body[0]['declarations'][0]['init']['elements'];\n\n      const parsedLiterals = literals.map(\n          (l) =>\n              parseExpressionInJsStringLiteral(javascriptDocument, l, 'full'));\n      const warnings = parsedLiterals.map((pl) => pl.warnings)\n                           .reduce((p, n) => p.concat(n), []);\n      const expressionRanges = parsedLiterals.map(\n          (pl) => pl.databinding && pl.databinding.sourceRange);\n      assert.deepEqual(await underliner.underline(expressionRanges), [\n        `\n          'foo(bar, baz)',\n           ~~~~~~~~~~~~~`,\n        `No source range given.`,\n        `No source range given.`,\n        `No source range given.`,\n        `No source range given.`,\n      ]);\n      assert.deepEqual(await underliner.underline(warnings), [\n        `\n          'foo(bar baz)',\n                   ~`,\n        `\n          10,\n          ~~`,\n        `\n          observerAssignedElsewhere,\n          ~~~~~~~~~~~~~~~~~~~~~~~~~`,\n      ]);\n    });\n  });\n});\n"]}