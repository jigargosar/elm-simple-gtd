{"version":3,"sources":["src/messaging/controllers/window-controller.ts"],"names":["WindowController","app","registrationToUse_","manifestCheckPromise_","messageObserver_","onMessage_","observer","tokenRefreshObserver_","onTokenRefresh_","setupSWMessageListener_","isSupported_","Promise","reject","errorFactory_","create","codes","UNSUPPORTED_BROWSER","manifestCheck_","then","manifestTag","document","querySelector","resolve","fetch","href","response","json","catch","manifestContent","INCORRECT_GCM_SENDER_ID","Notification","permission","granted","managePermissionResult","result","denied","PERMISSION_BLOCKED","PERMISSION_DEFAULT","permissionPromise","requestPermission","registration","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","USE_SW_BEFORE_GET_TOKEN","nextOrObserver","optError","optCompleted","serviceWorker","installing","waiting","active","NO_SW_IN_REG","state","SW_REG_REDUNDANT","stateChangeListener","removeEventListener","addEventListener","waitForRegistrationToActivate_","navigator","register","path","scope","FAILED_DEFAULT_REGISTRATION","err","message","update","event","data","PARAMS","TYPE_OF_MSG","workerPageMessage","TYPES_OF_MSG","PUSH_MSG_RECEIVED","NOTIFICATION_CLICKED","pushMessage","DATA","next","window","prototype","hasOwnProperty","PushSubscription"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;IAIcA,gB;;;AASZ;;;;AAIA,8BAAYC,GAAZ,EAAe;AAAA;;AAGb;;;;AAHa,wIACPA,GADO;;AAOb,cAAKC,kBAAL;AAEA;;;;AAIA,cAAKC,qBAAL;AAEA;;;;AAIA,cAAKC,gBAAL,GAAwB,IAAxB;AACA;;;;AAIA,cAAKC,UAAL,GAAkB,gCAAgB,oBAAQ;AACxC,kBAAKD,gBAAL,GAAwBE,QAAxB;AACD,SAFiB,CAAlB;AAIA;;;;AAIA,cAAKC,qBAAL,GAA6B,IAA7B;AACA,cAAKC,eAAL,GAAuB,gCAAgB,oBAAQ;AAC7C,kBAAKD,qBAAL,GAA6BD,QAA7B;AACD,SAFsB,CAAvB;AAIA,cAAKG,uBAAL;AArCa;AAsCd;AAED;;;;;;;;;;;;;mCASQ;AAAA;;AACN;AACA,gBAAI,CAAC,KAAKC,YAAL,EAAL,EAA0B;AACxB,uBAAOC,QAAQC,MAAR,CACL,KAAKC,aAAL,CAAmBC,MAAnB,CAA0B,iBAAOC,KAAP,CAAaC,mBAAvC,CADK,CAAP;AAGD;AAED,mBAAO,KAAKC,cAAL,GACNC,IADM,CACD,YAAA;AACJ;AACD,aAHM,CAAP;AAID;AAED;;;;;;;;;;yCAOc;AAAA;;AACZ,gBAAI,KAAKf,qBAAT,EAAgC;AAC9B,uBAAO,KAAKA,qBAAZ;AACD;AAED,gBAAMgB,cAAmCC,SAASC,aAAT,CAAuB,sBAAvB,CAAzC;AACA,gBAAI,CAACF,WAAL,EAAkB;AAChB,qBAAKhB,qBAAL,GAA6BQ,QAAQW,OAAR,EAA7B;AACD,aAFD,MAEO;AACL,qBAAKnB,qBAAL,GAA6BoB,MAAMJ,YAAYK,IAAlB,EAC5BN,IAD4B,CACvB,oBAAQ;AACZ,2BAAOO,SAASC,IAAT,EAAP;AACD,iBAH4B,EAI5BC,KAJ4B,CAItB,YAAA;AACL;AACA;AACA,2BAAOhB,QAAQW,OAAR,EAAP;AACD,iBAR4B,EAS5BJ,IAT4B,CASvB,2BAAe;AACnB,wBAAI,CAACU,eAAL,EAAsB;AACpB;AACD;AAED,wBAAI,CAACA,gBAAgB,eAAhB,CAAL,EAAuC;AACrC;AACD;AAED,wBAAIA,gBAAgB,eAAhB,MAAqC,cAAzC,EAAyD;AACvD,8BAAM,OAAKf,aAAL,CAAmBC,MAAnB,CACJ,iBAAOC,KAAP,CAAac,uBADT,CAAN;AAED;AACF,iBAtB4B,CAA7B;AAuBD;AAED,mBAAO,KAAK1B,qBAAZ;AACD;AAED;;;;;;;;;4CAMiB;AAAA;;AACf,gBAAK2B,aAAqBC,UAArB,KAAoC,iCAAwBC,OAAjE,EAA0E;AACxE,uBAAOrB,QAAQW,OAAR,EAAP;AACD;AAED,mBAAO,IAAIX,OAAJ,CAAY,UAACW,OAAD,EAAUV,MAAV,EAAgB;AACjC,oBAAMqB,yBAAyB,kBAAM;AACnC,wBAAIC,WAAW,iCAAwBF,OAAvC,EAAgD;AAC9C,+BAAOV,SAAP;AACD,qBAFD,MAEO,IAAIY,WAAW,iCAAwBC,MAAvC,EAA+C;AACpD,+BAAOvB,OAAO,OAAKC,aAAL,CAAmBC,MAAnB,CACZ,iBAAOC,KAAP,CAAaqB,kBADD,CAAP,CAAP;AAED,qBAHM,MAGA;AACL,+BAAOxB,OAAO,OAAKC,aAAL,CAAmBC,MAAnB,CACZ,iBAAOC,KAAP,CAAasB,kBADD,CAAP,CAAP;AAED;AACF,iBAVD;AAYA;AACA;AACA;AACA,oBAAMC,oBAAoBR,aAAaS,iBAAb,CAA+B,kBAAM;AAC7D,wBAAID,iBAAJ,EAAuB;AACrB;AACA;AACD;AAEDL,2CAAuBC,MAAvB;AACD,iBAPyB,CAA1B;AASA,oBAAII,iBAAJ,EAAuB;AACrB;AACAA,sCAAkBpB,IAAlB,CAAuBe,sBAAvB;AACD;AACF,aA7BM,CAAP;AA8BD;AAED;;;;;;;;;;yCAOiBO,Y,EAAY;AAC3B,gBAAI,EAAEA,wBAAwBC,yBAA1B,CAAJ,EAA0D;AACxD,sBAAM,KAAK5B,aAAL,CAAmBC,MAAnB,CAA0B,iBAAOC,KAAP,CAAa2B,wBAAvC,CAAN;AACD;AAED,gBAAI,OAAO,KAAKxC,kBAAZ,KAAmC,WAAvC,EAAoD;AAClD,sBAAM,KAAKW,aAAL,CAAmBC,MAAnB,CAA0B,iBAAOC,KAAP,CAAa4B,uBAAvC,CAAN;AACD;AAED,iBAAKzC,kBAAL,GAA0BsC,YAA1B;AACD;AAED;;;;;;;;;;;;;kCAUUI,c,EAAgBC,Q,EAAUC,Y,EAAY;AAC9C,mBAAO,KAAKzC,UAAL,CAAgBuC,cAAhB,EAAgCC,QAAhC,EAA0CC,YAA1C,CAAP;AACD;AAED;;;;;;;;;;;;;uCAUeF,c,EAAgBC,Q,EAAUC,Y,EAAY;AACnD,mBAAO,KAAKtC,eAAL,CAAqBoC,cAArB,EAAqCC,QAArC,EAA+CC,YAA/C,CAAP;AACD;AAED;;;;;;;;;;;;uDAS+BN,Y,EAAY;AAAA;;AACzC,gBAAMO,gBAAgBP,aAAaQ,UAAb,IAA2BR,aAAaS,OAAxC,IACpBT,aAAaU,MADf;AAGA,mBAAO,IAAIvC,OAAJ,CAAY,UAACW,OAAD,EAAUV,MAAV,EAAgB;AACjC,oBAAI,CAACmC,aAAL,EAAoB;AAClB;AACAnC,2BAAO,OAAKC,aAAL,CAAmBC,MAAnB,CAA0B,iBAAOC,KAAP,CAAaoC,YAAvC,CAAP;AACA;AACD;AACD;AACA;AACA,oBAAIJ,cAAcK,KAAd,KAAwB,WAA5B,EAAyC;AACvC9B,4BAAQkB,YAAR;AACA;AACD;AAED,oBAAIO,cAAcK,KAAd,KAAwB,WAA5B,EAAyC;AACvCxC,2BAAO,OAAKC,aAAL,CAAmBC,MAAnB,CAA0B,iBAAOC,KAAP,CAAasC,gBAAvC,CAAP;AACA;AACD;AAED,oBAAIC,sBAAsB,YAAA;AACxB,wBAAIP,cAAcK,KAAd,KAAwB,WAA5B,EAAyC;AACvC9B,gCAAQkB,YAAR;AACD,qBAFD,MAEO,IAAIO,cAAcK,KAAd,KAAwB,WAA5B,EAAyC;AAC9CxC,+BAAO,OAAKC,aAAL,CAAmBC,MAAnB,CAA0B,iBAAOC,KAAP,CAAasC,gBAAvC,CAAP;AACD,qBAFM,MAEA;AACL;AACA;AACD;AACDN,kCAAcQ,mBAAd,CAAkC,aAAlC,EAAiDD,mBAAjD;AACD,iBAVD;AAWAP,8BAAcS,gBAAd,CAA+B,aAA/B,EAA8CF,mBAA9C;AACD,aA9BM,CAAP;AA+BD;AAED;;;;;;;;;6CAMkB;AAAA;;AAChB,gBAAI,KAAKpD,kBAAT,EAA6B;AAC3B,uBAAO,KAAKuD,8BAAL,CAAoC,KAAKvD,kBAAzC,CAAP;AACD;AAED;AACA;AACA,iBAAKA,kBAAL,GAA0B,IAA1B;AAEA,mBAAOwD,UAAUX,aAAV,CAAwBY,QAAxB,CAAiC,oBAAUC,IAA3C,EAAiD;AACtDC,uBAAO,oBAAUA;AADqC,aAAjD,EAGNlC,KAHM,CAGA,eAAG;AACR,sBAAM,OAAKd,aAAL,CAAmBC,MAAnB,CACJ,iBAAOC,KAAP,CAAa+C,2BADT,EACsC;AACxC,2CAAuBC,IAAIC;AADa,iBADtC,CAAN;AAKD,aATM,EAUN9C,IAVM,CAUD,wBAAY;AAChB,uBAAO,OAAKuC,8BAAL,CAAoCjB,YAApC,EACNtB,IADM,CACD,YAAA;AACJ,2BAAKhB,kBAAL,GAA0BsC,YAA1B;AAEA;AACA;AACA;AACAA,iCAAayB,MAAb;AAEA,2BAAOzB,YAAP;AACD,iBAVM,CAAP;AAWD,aAtBM,CAAP;AAuBD;AAED;;;;;;;;;;kDAOuB;AAAA;;AACrB,gBAAI,EAAE,mBAAmBkB,SAArB,CAAJ,EAAqC;AACnC;AACD;AAEDA,sBAAUX,aAAV,CAAwBS,gBAAxB,CAAyC,SAAzC,EAAoD,iBAAK;AACvD,oBAAI,CAACU,MAAMC,IAAP,IAAe,CAACD,MAAMC,IAAN,CAAW,4BAAkBC,MAAlB,CAAyBC,WAApC,CAApB,EAAsE;AACpE;AACA;AACD;AAED,oBAAMC,oBAAoBJ,MAAMC,IAAhC;AACA,wBAAQG,kBAAkB,4BAAkBF,MAAlB,CAAyBC,WAA3C,CAAR;AACE,yBAAK,4BAAkBE,YAAlB,CAA+BC,iBAApC;AACA,yBAAK,4BAAkBD,YAAlB,CAA+BE,oBAApC;AACE,4BAAMC,cAAcJ,kBAAkB,4BAAkBF,MAAlB,CAAyBO,IAA3C,CAApB;AACA,+BAAKvE,gBAAL,CAAsBwE,IAAtB,CAA2BF,WAA3B;AACA;AACF;AACE;AACA;AARJ;AAUD,aAjBD,EAiBG,KAjBH;AAkBD;AAED;;;;;;;;uCAKY;AACV,mBAAO,mBAAmBhB,SAAnB,IACH,iBAAiBmB,MADd,IAEH,kBAAkBA,MAFf,IAGHpC,0BAA0BqC,SAA1B,CACKC,cADL,CACoB,kBADpB,CAHG,IAKHC,iBAAiBF,SAAjB,CAA2BC,cAA3B,CAA0C,QAA1C,CALJ;AAMD;;;;;;kBApVW/E,gB","file":"window-controller.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport DefaultSW from '../models/default-sw';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport {createSubscribe} from '../../app/subscribe';\n\ndeclare const firebase: any;\n\nexport default class WindowController extends ControllerInterface {\n\n  private registrationToUse_;\n  private manifestCheckPromise_;\n  private messageObserver_;\n  private onMessage_;\n  private tokenRefreshObserver_;\n  private onTokenRefresh_;\n\n  /**\n   * A service that provides a MessagingService instance.\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    super(app);\n\n    /**\n     * @private\n     * @type {ServiceWorkerRegistration}\n     */\n    this.registrationToUse_;\n\n    /**\n     * @private\n     * @type {Promise}\n     */\n    this.manifestCheckPromise_;\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.messageObserver_ = null;\n    /**\n     * @private {!firebase.Subscribe} The subscribe function to the onMessage\n     * observer.\n     */\n    this.onMessage_ = createSubscribe(observer => {\n      this.messageObserver_ = observer;\n    });\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.tokenRefreshObserver_ = null;\n    this.onTokenRefresh_ = createSubscribe(observer => {\n      this.tokenRefreshObserver_ = observer;\n    });\n\n    this.setupSWMessageListener_();\n  }\n\n  /**\n   * This method returns an FCM token if it can be generated.\n   * The return promise will reject if the browser doesn't support\n   * FCM, if permission is denied for notifications or it's not\n   * possible to generate a token.\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise the\n   * resolves to an FCM token or null if permission isn't granted.\n   */\n  getToken() {\n    // Check that the required API's are available\n    if (!this.isSupported_()) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.UNSUPPORTED_BROWSER)\n      );\n    }\n\n    return this.manifestCheck_()\n    .then(() => {\n      return super.getToken();\n    });\n  }\n\n  /**\n   * The method checks that a manifest is defined and has the correct GCM\n   * sender ID.\n   * @private\n   * @return {Promise} Returns a promise that resolves if the manifest matches\n   * our required sender ID\n   */\n  manifestCheck_() {\n    if (this.manifestCheckPromise_) {\n      return this.manifestCheckPromise_;\n    }\n\n    const manifestTag = (<HTMLAnchorElement> document.querySelector('link[rel=\"manifest\"]'));\n    if (!manifestTag) {\n      this.manifestCheckPromise_ = Promise.resolve();\n    } else {\n      this.manifestCheckPromise_ = fetch(manifestTag.href)\n      .then(response => {\n        return response.json();\n      })\n      .catch(() => {\n        // If the download or parsing fails allow check.\n        // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n        return Promise.resolve();\n      })\n      .then(manifestContent => {\n        if (!manifestContent) {\n          return;\n        }\n\n        if (!manifestContent['gcm_sender_id']) {\n          return;\n        }\n\n        if (manifestContent['gcm_sender_id'] !== '103953800507') {\n          throw this.errorFactory_.create(\n            Errors.codes.INCORRECT_GCM_SENDER_ID);\n        }\n      });\n    }\n\n    return this.manifestCheckPromise_;\n  }\n\n  /**\n   * Request permission if it is not currently granted\n   * @export\n   * @returns {Promise} Resolves if the permission was granted, otherwise\n   * rejects\n   */\n  requestPermission() {\n    if ((Notification as any).permission === NOTIFICATION_PERMISSION.granted) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const managePermissionResult = result => {\n        if (result === NOTIFICATION_PERMISSION.granted) {\n          return resolve();\n        } else if (result === NOTIFICATION_PERMISSION.denied) {\n          return reject(this.errorFactory_.create(\n            Errors.codes.PERMISSION_BLOCKED));\n        } else {\n          return reject(this.errorFactory_.create(\n            Errors.codes.PERMISSION_DEFAULT));\n        }\n      };\n\n      // The Notification.requestPermission API was changed to\n      // return a promise so now have to handle both in case\n      // browsers stop support callbacks for promised version\n      const permissionPromise = Notification.requestPermission(result => {\n        if (permissionPromise) {\n          // Let the promise manage this\n          return;\n        }\n\n        managePermissionResult(result);\n      });\n\n      if (permissionPromise) {\n        // Prefer the promise version as it's the future API.\n        permissionPromise.then(managePermissionResult);\n      }\n    });\n  }\n\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   * @export\n   * @param {!ServiceWorkerRegistration} registration The service worker\n   * registration that should be used to receive the push messages.\n   */\n  useServiceWorker(registration) {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (typeof this.registrationToUse_ !== 'undefined') {\n      throw this.errorFactory_.create(Errors.codes.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse_ = registration;\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\n   * or a function triggered on message.\n   * @param {function(!Error)=} optError Optional A function triggered on\n   * message error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    return this.onMessage_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @private\n   * @param  {ServiceWorkerRegistration} registration Registration to wait\n   * for service worker to become active\n   * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\n   * registration to become active\n   */\n  waitForRegistrationToActivate_(registration) {\n    const serviceWorker = registration.installing || registration.waiting ||\n      registration.active;\n\n    return new Promise((resolve, reject) => {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(this.errorFactory_.create(Errors.codes.NO_SW_IN_REG));\n        return;\n      }\n      // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        return;\n      }\n\n      let stateChangeListener = () => {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  }\n\n  /**\n   * This will regiater the default service worker and return the registration\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    if (this.registrationToUse_) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse_);\n    }\n\n    // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse_ is no longer undefined\n    this.registrationToUse_ = null;\n\n    return navigator.serviceWorker.register(DefaultSW.path, {\n      scope: DefaultSW.scope\n    })\n    .catch(err => {\n      throw this.errorFactory_.create(\n        Errors.codes.FAILED_DEFAULT_REGISTRATION, {\n          'browserErrorMessage': err.message\n        }\n      );\n    })\n    .then(registration => {\n      return this.waitForRegistrationToActivate_(registration)\n      .then(() => {\n        this.registrationToUse_ = registration;\n\n        // We update after activation due to an issue with Firefox v49 where\n        // a race condition occassionally causes the service work to not\n        // install\n        registration.update();\n\n        return registration;\n      });\n    });\n  }\n\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   *\n   * @private\n   */\n  setupSWMessageListener_() {\n    if (!('serviceWorker' in navigator)) {\n      return;\n    }\n\n    navigator.serviceWorker.addEventListener('message', event => {\n      if (!event.data || !event.data[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n        // Not a message from FCM\n        return;\n      }\n\n      const workerPageMessage = event.data;\n      switch (workerPageMessage[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n        case WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n        case WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n          const pushMessage = workerPageMessage[WorkerPageMessage.PARAMS.DATA];\n          this.messageObserver_.next(pushMessage);\n          break;\n        default:\n          // Noop.\n          break;\n      }\n    }, false);\n  }\n\n  /**\n   * Checks to see if the required API's are valid or not.\n   * @private\n   * @return {boolean} Returns true if the desired APIs are available.\n   */\n  isSupported_() {\n    return 'serviceWorker' in navigator &&\n        'PushManager' in window &&\n        'Notification' in window &&\n        ServiceWorkerRegistration.prototype\n            .hasOwnProperty('showNotification') &&\n        PushSubscription.prototype.hasOwnProperty('getKey');\n  }\n}\n"]}