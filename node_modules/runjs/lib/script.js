'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.requirer = requirer;
exports.hasAccess = hasAccess;
exports.config = config;
exports.load = load;
exports.describe = describe;
exports.call = call;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _common = require('./common');

var _getParameterNames = require('get-parameter-names');

var _getParameterNames2 = _interopRequireDefault(_getParameterNames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function requirer(filePath) {
  return require(_path2.default.resolve(filePath));
}

function hasAccess(filePath) {
  return _fs2.default.accessSync(_path2.default.resolve(filePath));
}

function config(filePath) {
  var config = void 0;
  try {
    config = require(filePath).runjs || {};
  } catch (error) {
    config = {};
  }
  return config;
}

function load(runfilePath, config, logger, requirer, access) {
  // try to load babel-register
  try {
    logger.log('Requiring babel-register...');
    if (config['babel-register']) {
      requirer(config['babel-register']);
    } else {
      requirer('./node_modules/babel-register');
    }
  } catch (error) {
    logger.log('Requiring failed. Fallback to pure node.');
    if (config['babel-register']) {
      throw error;
    }
  }

  // process runfile.js
  logger.log('Processing runfile...');

  try {
    access(runfilePath + '.js');
  } catch (error) {
    throw new _common.RunJSError('No ' + runfilePath + '.js defined in ' + process.cwd());
  }

  var runfile = requirer(runfilePath);
  if (runfile.default) {
    return runfile.default;
  }
  return runfile;
}

function parseArgs(args) {
  var options = {};
  var nextArgs = args.filter(function (arg) {
    var doubleDashMatch = arg.match(/^--([\w-.]+)=([\w-.]*)$/) || arg.match(/^--([\w-.]+)$/);
    var singleDashMatch = arg.match(/^-(?!-)([\w-.])=([\w-.]*)$/) || arg.match(/^-(?!-)([\w-.])$/);

    if (singleDashMatch) {
      options[singleDashMatch[1]] = Number(singleDashMatch[2]) || singleDashMatch[2] || true;
      return false;
    }

    if (doubleDashMatch) {
      options[doubleDashMatch[1]] = Number(doubleDashMatch[2]) || doubleDashMatch[2] || true;
      return false;
    }

    return true;
  });

  return {
    nextArgs: nextArgs,
    options: options
  };
}

function describe(obj, logger, namespace) {
  if (!namespace) {
    logger.debug('Available tasks:\n');
  }

  Object.keys(obj).forEach(function (key) {
    var value = obj[key];
    var nextNamespace = namespace ? namespace + ':' + key : key;
    var help = value.help;

    if (typeof value === 'function') {
      var funcParams = void 0;
      try {
        funcParams = (0, _getParameterNames2.default)(value);
      } catch (error) {
        funcParams = [];
      }
      var paramsDoc = funcParams.length ? '[' + funcParams.join(' ') + ']' : '';
      logger.info(nextNamespace, paramsDoc);
      if (help) {
        logger.log(help);
      }
      logger.info(' ');
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      describe(value, logger, nextNamespace);
    }
  });
}

function help(task, logger) {
  logger.log(' ');
  logger.info('ARGUMENTS');
  var params = (0, _getParameterNames2.default)(task);
  if (params.length) {
    logger.log('[' + params.join(' ') + ']');
  } else {
    logger.log('None');
  }
  logger.log(' ');
  logger.info('DESCRIPTION');
  logger.log(task.help || 'None');
  logger.log(' ');
}

function call(obj, args, logger) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var taskName = args[0];

  if (typeof obj[taskName] === 'function') {
    var _parseArgs = parseArgs(args.slice(1)),
        _nextArgs = _parseArgs.nextArgs,
        options = _parseArgs.options;

    if (options.help) {
      help(obj[taskName], logger);
    } else {
      obj[taskName].apply({ options: options }, _nextArgs);
    }
    return obj[taskName];
  }

  var namespaces = taskName.split(':');
  var rootNamespace = namespaces.shift();
  var nextTaskName = namespaces.join(':');
  var nextArgs = args.slice();
  nextArgs[0] = nextTaskName;

  if (obj[rootNamespace]) {
    var calledTask = call(obj[rootNamespace], nextArgs, logger, depth + 1);
    if (calledTask) {
      return calledTask;
    }
  }

  if (!depth) {
    throw new _common.RunJSError('Task ' + taskName + ' not found');
  }
}