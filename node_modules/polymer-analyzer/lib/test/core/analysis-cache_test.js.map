{"version":3,"sources":["test/core/analysis-cache_test.ts"],"names":[],"mappings":"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","file":"analysis-cache_test.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {assert} from 'chai';\n\nimport {AnalysisCache} from '../../core/analysis-cache';\n\nsuite('AnalysisCache', () => {\n  test('it can be constructed', () => {\n    new AnalysisCache();\n  });\n\n  function addFakeDocumentToCache(\n      cache: AnalysisCache, path: string, dependencies: string[]) {\n    cache.parsedDocumentPromises.set(path, `parsed ${path} promise` as any);\n    cache.scannedDocumentPromises.set(path, `scanned ${path} promise` as any);\n    cache.analyzedDocumentPromises.set(path, `analyzed ${path} promise` as any);\n    cache.scannedDocuments.set(path, `scanned ${path}` as any);\n    cache.analyzedDocuments.set(path, `analyzed ${path}` as any);\n    cache.dependencyGraph.addDocument(path, dependencies);\n  }\n\n  async function assertHasDocument(cache: AnalysisCache, path: string) {\n    assert.equal(\n        await cache.parsedDocumentPromises.getOrCompute(\n            path, null as any) as any,\n        `parsed ${path} promise`);\n    assert.equal(\n        await cache.scannedDocumentPromises.getOrCompute(\n            path, null as any) as any,\n        `scanned ${path} promise`);\n    // caller must assert on cache.analyzedDocumentPromises themselves\n    assert.equal(cache.scannedDocuments.get(path) as any, `scanned ${path}`);\n    assert.equal(cache.analyzedDocuments.get(path) as any, `analyzed ${path}`);\n  }\n\n  function assertNotHasDocument(cache: AnalysisCache, path: string) {\n    assert.isFalse(cache.parsedDocumentPromises.has(path));\n    assert.isFalse(cache.scannedDocumentPromises.has(path));\n    // caller must assert on cache.analyzedDocumentPromises themselves\n    assert.isFalse(cache.scannedDocuments.has(path));\n    assert.isFalse(cache.analyzedDocuments.has(path));\n  }\n\n  async function assertDocumentScannedButNotResolved(\n      cache: AnalysisCache, path: string) {\n    assert.equal(\n        await cache.parsedDocumentPromises.getOrCompute(\n            path, null as any) as any,\n        `parsed ${path} promise`);\n\n    assert.equal(\n        await cache.scannedDocumentPromises.getOrCompute(\n            path, null as any) as any,\n        `scanned ${path} promise`);\n    assert.equal(cache.scannedDocuments.get(path) as any, `scanned ${path}`);\n    assert.isFalse(cache.analyzedDocuments.has(path));\n    assert.isFalse(cache.analyzedDocumentPromises.has(path));\n  }\n\n  test('it invalidates a path when asked to', async() => {\n    const cache = new AnalysisCache();\n    addFakeDocumentToCache(cache, 'index.html', []);\n    addFakeDocumentToCache(cache, 'unrelated.html', []);\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n\n    const forkedCache = cache.invalidate(['index.html']);\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n    assertNotHasDocument(forkedCache, 'index.html');\n    await assertHasDocument(forkedCache, 'unrelated.html');\n\n    // The promise of unrelated.html's result has been turned into\n    // a Promise.resolve() of its non-promise cache.\n    assert.equal(\n        await forkedCache.analyzedDocumentPromises.getOrCompute(\n            'unrelated.html', null as any) as any,\n        `analyzed unrelated.html`);\n  });\n\n  test('it invalidates the dependants of a path when asked to', async() => {\n    const cache = new AnalysisCache();\n    // Picture a graph where\n    addFakeDocumentToCache(cache, 'index.html', ['element.html']);\n    addFakeDocumentToCache(cache, 'element.html', ['behavior.html']);\n    addFakeDocumentToCache(cache, 'behavior.html', []);\n    addFakeDocumentToCache(cache, 'unrelated.html', []);\n\n    // We added the documents.\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n    await assertHasDocument(cache, 'behavior.html');\n    await assertHasDocument(cache, 'unrelated.html');\n\n\n    const forkedCache = cache.invalidate(['behavior.html']);\n    // The original cache is untouched.\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n    await assertHasDocument(cache, 'behavior.html');\n    await assertHasDocument(cache, 'unrelated.html');\n\n    // The fork has no trace of behavior.html, and its dependants are scanned\n    // but not resolved. Unrelated documents are still fully cached.\n    assertNotHasDocument(forkedCache, 'behavior.html');\n    await assertDocumentScannedButNotResolved(forkedCache, 'index.html');\n    await assertDocumentScannedButNotResolved(forkedCache, 'element.html');\n    await assertHasDocument(forkedCache, 'unrelated.html');\n  });\n});\n"]}