{"version":3,"sources":["../src/app/firebase_app.ts"],"names":["createFirebaseNamespace","contains","obj","key","Object","prototype","hasOwnProperty","call","LocalPromise","Promise","DEFAULT_ENTRY_NAME","tokenListeners","FirebaseAppImpl","options","name","firebase_","isDeleted_","services_","name_","options_","INTERNAL","resolve","callback","push","setTimeout","filter","listener","checkDestroyed_","then","removeApp","services","keys","forEach","serviceKey","instanceKey","all","map","service","delete","instanceIdentifier","instanceSpecifier","undefined","factories","extendApp","bind","props","addAuthTokenListener","error","console","log","apps_","appHooks","namespace","app","callAppHooks","createService","serviceProperties","appHook","allowMultipleInstances","getApps","serviceNamespace","appArg","serviceFxn","_getService","args","apply","useAsService","GoogPromise","defineProperty","get","eventName","serviceName","factoryName","code","appErrors","create","errors"],"mappings":"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","file":"firebase_app.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { \n  createSubscribe,\n  Observer,\n  Subscribe\n} from './subscribe';\nimport { \n  ErrorFactory,\n  FirebaseError\n} from './errors';\nimport { local } from './shared_promise';\nimport { patchProperty, deepCopy, deepExtend } from './deep_copy';\n\nexport interface FirebaseAuthTokenData { accessToken: string; }\n\nexport interface FirebaseAppInternals {\n  getToken(refreshToken?: boolean): Promise< FirebaseAuthTokenData | null >;\n  getUid(): string|null;\n  addAuthTokenListener(fn: (token: string|null) => void): void;\n  removeAuthTokenListener(fn: (token: string|null) => void): void;\n}\n\nexport type FirebaseOptions = { \n  apiKey?: string,\n  authDomain?: string,\n  databaseURL?: string,\n  projectId?: string,\n  storageBucket?: string,\n  messagingSenderId?: string\n  [name: string]: any \n};\n\n// An instance of the firebase.App\nexport interface FirebaseApp {\n  /**\n   * The (read-only) name (identifier) for this App. '[DEFAULT]' is the default\n   * App.\n   */\n  name: string;\n\n  /**\n   * The (read-only) configuration options from the app initialization.\n   */\n  options: FirebaseOptions;\n\n  /**\n   * Make the given App unusable and free resources.\n   */\n  delete(): Promise<void>;\n\n  INTERNAL: FirebaseAppInternals;\n}\n\nexport interface FirebaseServiceInternals {\n  /**\n   * Delete the service and free it's resources - called from\n   * app.delete().\n   */\n  delete(): Promise<void>;\n}\n\n// Services are exposed through instances - each of which is associated with a\n// FirebaseApp.\nexport interface FirebaseService {\n  app: FirebaseApp;\n  INTERNAL?: FirebaseServiceInternals;\n}\n\nexport type AppHook = (event: string, app: FirebaseApp) => void;\n\n/**\n * Firebase Services create instances given a Firebase App instance and can\n * optionally add properties and methods to each FirebaseApp via the extendApp()\n * function.\n */\nexport interface FirebaseServiceFactory {\n  (app: FirebaseApp, extendApp?: (props: {[prop: string]: any}) => void,\n   instanceString?: string): FirebaseService;\n}\n\n/**\n * All ServiceNamespaces extend from FirebaseServiceNamespace\n */\nexport interface FirebaseServiceNamespace <T extends FirebaseService> {\n  (app?: FirebaseApp): T;\n}\n\nexport interface FirebaseErrorFactory<T> {\n  create(code: T, data?: {[prop: string]: any}): FirebaseError;\n}\n\nexport interface FirebaseErrorFactoryClass {\n  new (service: string, serviceName: string, errors: {[code: string]: string}): FirebaseErrorFactory<any>;\n}\n\nexport interface FirebaseNamespace {\n  /**\n   * Create (and intialize) a FirebaseApp.\n   *\n   * @param options Options to configure the services use in the App.\n   * @param name The optional name of the app to initialize ('[DEFAULT]' if\n   *   none)\n   */\n  initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n\n  app: {\n    /**\n     * Retrieve an instance of a FirebaseApp.\n     *\n     * Usage: firebase.app()\n     *\n     * @param name The optional name of the app to return ('[DEFAULT]' if none)\n     */\n    (name?: string): FirebaseApp;\n\n    /**\n     * For testing FirebaseApp instances:\n     *   app() instanceof firebase.app.App\n     * DO NOT call this constuctor directly (use firebase.app() instead).\n     */\n    App: Function;\n  };\n\n  /**\n   * A (read-only) array of all the initialized Apps.\n   */\n  apps: FirebaseApp[];\n\n  // Inherit the type information of our exported Promise implementation from\n  // es6-promises.\n  Promise: typeof Promise;\n\n  // The current SDK version ('4.1.3').\n  SDK_VERSION: string;\n\n  // TODO: Migrate to firebase-app-internal.d.ts\n  INTERNAL: {\n    /**\n     * Internal API to register a Firebase Service into the firebase namespace.\n     *\n     * Each service will create a child namespace (firease.name) which acts as\n     * both a namespace for service specific properties, and also as a service\n     * accessor function (firebase.name() or firebase.name(app)).\n     *\n     * @param name The Firebase Service being registered.\n     * @param createService Factory function to create a service instance.\n     * @param serviceProperties Properties to copy to the service's namespace.\n     * @param appHook All appHooks called before intializeApp returns to caller.\n     * @param allowMultipleInstances Whether the registered service supports\n     *   multiple instances per app. If not specified, the default is false.\n     */\n    registerService(\n        name: string, \n        createService: FirebaseServiceFactory,\n        serviceProperties?: {[prop: string]: any}, \n        appHook?: AppHook,\n        allowMultipleInstances?: boolean): FirebaseServiceNamespace<FirebaseService>;\n\n    /**\n     * Just used for testing to start from a fresh namespace.\n     */\n    createFirebaseNamespace(): FirebaseNamespace;\n\n    /**\n     * Internal API to install properties on the top-level firebase namespace.\n     * @prop props The top level properties of this object are copied to the\n     *   namespace.\n     */\n    extendNamespace(props: {[prop: string]: any}): void;\n\n    /**\n     * Create a Subscribe function.  A proxy Observer is created so that\n     * events can be sent to single Observer to be fanned out automatically.\n     */\n    createSubscribe<T>(\n        executor: (observer: Observer<T>) => void,\n        onNoObservers?: (observer: Observer<T>) => void): Subscribe<T>;\n\n    /**\n     * Utility exposed for internal testing.\n     */\n    deepExtend(target: any, source: any): any;\n\n    /**\n     * Internal API to remove an app from the list of registered apps.\n     */\n    removeApp(name: string): void;\n\n    /**\n     * Service factories for each registered service.\n     */\n    factories: {[name: string]: FirebaseServiceFactory};\n\n    /*\n     * Convert service name to factory name to use.\n     */\n    useAsService(app: FirebaseApp, serviceName: string): string | null;\n\n    /**\n     * Use to construct all thrown FirebaseError's.\n     */\n    ErrorFactory: FirebaseErrorFactoryClass;\n  }\n}\n\nconst contains = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nlet LocalPromise = local.Promise as typeof Promise;\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nclass FirebaseAppImpl implements FirebaseApp {\n  private options_: FirebaseOptions;\n  private name_: string;\n  private isDeleted_ = false;\n  private services_: {\n    [name: string]: {\n      [serviceName: string]: FirebaseService\n    }\n  } = {};\n\n  public INTERNAL;\n\n  constructor(options: FirebaseOptions,\n              name: string,\n              private firebase_: FirebaseNamespace) {\n    this.name_ = name;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      'getUid': () => null,\n      'getToken': () => LocalPromise.resolve(null),\n      'addAuthTokenListener': (callback: (token: string|null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      'removeAuthTokenListener': (callback) => {\n        tokenListeners = tokenListeners.filter(listener => listener !== callback);\n      },\n    };\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new LocalPromise((resolve) => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        let services: FirebaseService[] = [];\n        Object.keys(this.services_).forEach((serviceKey) => {\n          Object.keys(this.services_[serviceKey]).forEach((instanceKey) => {\n            services.push(this.services_[serviceKey][instanceKey]);\n          });\n        });\n        return LocalPromise.all(services.map((service) => {\n          return service.INTERNAL!.delete();\n        }));\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   * \n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   * \n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   * \n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(name: string, instanceIdentifier: string = DEFAULT_ENTRY_NAME): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: {[name: string]: any}): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     * \n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should \n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error('app-deleted', {'name': this.name_});\n    }\n  }\n};\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\nFirebaseAppImpl.prototype.name &&\n  FirebaseAppImpl.prototype.options ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log(\"dc\");\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  let apps_: {[name: string]: FirebaseApp} = {};\n  let factories: {[service: string]: FirebaseServiceFactory} = {};\n  let appHooks: {[service: string]: AppHook} = {};\n\n  // A namespace is a plain JavaScript Object.\n  let namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    '__esModule': true,\n    'initializeApp': initializeApp,\n    'app': app as any,\n    'apps': null as any,\n    'Promise': LocalPromise,\n    'SDK_VERSION': '4.1.3',\n    'INTERNAL': {\n      'registerService': registerService,\n      'createFirebaseNamespace': createFirebaseNamespace,\n      'extendNamespace': extendNamespace,\n      'createSubscribe': createSubscribe,\n      'ErrorFactory': ErrorFactory,\n      'removeApp': removeApp,\n      'factories': factories,\n      'useAsService': useAsService,\n      'Promise': local.GoogPromise as typeof Promise,\n      'deepExtend': deepExtend,\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    let app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', {'name': name});\n    }\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', {'name': name + ''});\n      }\n    }\n    if (contains(apps_, name) ) {\n      error('duplicate-app', {'name': name});\n    }\n\n    let app = new FirebaseAppImpl(options, name!, namespace as FirebaseNamespace);\n\n    apps_[name!] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map((name) => apps_[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n      name: string, \n      createService: FirebaseServiceFactory,\n      serviceProperties?: {[prop: string]: any}, \n      appHook?: AppHook,\n      allowMultipleInstances?: boolean):\n      FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', {'name': name});\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n    \n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    const serviceNamespace = (appArg: FirebaseApp = app()) => {\n      if (typeof(appArg as any)[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', {'name': name});\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return (appArg as any)[name]();\n    };\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    (namespace as any)[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    }\n\n    return serviceNamespace;\n  }\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: {[prop: string]: any}): void {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    Object.keys(factories).forEach((serviceName) => {\n      // Ignore virtual services\n      let factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    let useService = name;\n    let options = app.options;\n\n    return useService;\n  }\n\n  return (namespace as any) as FirebaseNamespace;\n}\n\ntype AppError = 'no-app'|'bad-app-name'|'duplicate-app'|'app-deleted'|\n    'duplicate-service'|'sa-not-supported'|'invalid-app-argument';\n\nfunction error(code: AppError, args?: {[name: string]: any}) {\n  throw appErrors.create(code, args);\n}\n\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nlet errors: {[code: string]: string} = {\n  'no-app': 'No Firebase App \\'{$name}\\' has been created - ' +\n      'call Firebase App.initializeApp()',\n  'bad-app-name': 'Illegal App name: \\'{$name}',\n  'duplicate-app': 'Firebase App named \\'{$name}\\' already exists',\n  'app-deleted': 'Firebase App named \\'{$name}\\' already deleted',\n  'duplicate-service': 'Firebase service named \\'{$name}\\' already registered',\n  'sa-not-supported': 'Initializing the Firebase SDK with a service ' +\n      'account is only allowed in a Node.js environment. On client ' +\n      'devices, you should instead initialize the SDK with an api key and ' +\n      'auth domain',\n  'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' +\n      'Firebase App instance.'\n};\n\nlet appErrors = new ErrorFactory<AppError>('app', 'Firebase', errors);\n"]}