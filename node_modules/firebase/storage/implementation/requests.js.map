{"version":3,"sources":["src/storage/implementation/requests.ts"],"names":["handlerCheck","metadataHandler","sharedErrorHandler","objectErrorHandler","getMetadata","updateMetadata","deleteObject","determineContentType_","metadataForUpload_","multipartUpload","checkResumeHeader_","createResumableUpload","getResumableUploadStatus","continueResumableUpload","array","errorsExports","MetadataUtils","object","type","UrlUtils","cndn","unknown","authWrapper","mappings","xhr","text","metadata","fromResourceString","location","err","newErr","getStatus","unauthenticated","quotaExceeded","bucket","unauthorized","path","setServerResponseProp","serverResponseProp","shared","objectNotFound","urlPart","fullServerUrl","url","makeNormalUrl","timeout","maxOperationRetryTime","requestInfo","errorHandler","body","toResourceString","headers","successCodes","blob","opt_metadata","clone","size","bucketOnlyServerUrl","boundary","str","i","Math","random","toString","slice","metadataString","preBlobPart","getBlob","cannotSliceBlob","urlParams","makeUploadUrl","maxUploadRetryTime","uploadData","ResumableUploadStatus","current","total","finalized","opt_allowed","status","getResponseHeader","e","contains","isString","sizeString","parseInt","isNaN","resumableUploadChunkSize","chunkSize","opt_status","opt_progressCallback","serverFileWrongSize","bytesLeft","bytesToUpload","min","startByte","endByte","uploadCommand","uploadStatus","newCurrent","progressCallback"],"mappings":"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","file":"requests.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Defines methods for interacting with the network.\n */\n\nimport {Metadata} from '../metadata';\n\nimport * as array from './array';\nimport {AuthWrapper} from './authwrapper';\nimport {FbsBlob} from './blob';\nimport * as errorsExports from './error';\nimport {FirebaseStorageError} from './error';\nimport {errors} from './error';\nimport {Location} from './location';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport {RequestInfo} from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport {XhrIo} from './xhrio';\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn: boolean) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\n\nexport function metadataHandler(\n    authWrapper: AuthWrapper,\n    mappings: MetadataUtils.Mappings): (p1: XhrIo, p2: string) => Metadata {\n  function handler(xhr: XhrIo, text: string): Metadata {\n    let metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n    handlerCheck(metadata !== null);\n    return metadata as Metadata;\n  }\n  return handler;\n}\n\nexport function sharedErrorHandler(location: Location): (\n    p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  function errorHandler(xhr: XhrIo, err: FirebaseStorageError): FirebaseStorageError {\n    let newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function objectErrorHandler(location: Location): (\n    p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  let shared = sharedErrorHandler(location);\n\n  function errorHandler(xhr: XhrIo, err: FirebaseStorageError): FirebaseStorageError {\n    let newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function getMetadata(\n    authWrapper: AuthWrapper, location: Location,\n    mappings: MetadataUtils.Mappings): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'GET';\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n      url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function updateMetadata(\n    authWrapper: AuthWrapper, location: Location, metadata: Metadata,\n    mappings: MetadataUtils.Mappings): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'PATCH';\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let headers = {'Content-Type': 'application/json; charset=utf-8'};\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n      url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function deleteObject(\n    authWrapper: AuthWrapper, location: Location): RequestInfo<void> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'DELETE';\n  let timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr: XhrIo, text: string) {}\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function determineContentType_(\n    metadata: Metadata|null, blob: FbsBlob|null): string {\n  return metadata && metadata['contentType'] || blob && blob.type() ||\n      'application/octet-stream';\n}\n\nexport function metadataForUpload_(\n    location: Location, blob: FbsBlob, opt_metadata?: Metadata|null): Metadata {\n  let metadata = object.clone<Metadata>(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\n\nexport function multipartUpload(\n    authWrapper: AuthWrapper, location: Location, mappings: MetadataUtils.Mappings,\n    blob: FbsBlob, opt_metadata?: Metadata|null): RequestInfo<Metadata> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let headers: { [prop: string]: string } = {'X-Goog-Upload-Protocol': 'multipart'};\n\n  function genBoundary() {\n    let str = '';\n    for (let i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n    return str;\n  }\n  let boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  let preBlobPart = '--' + boundary + '\\r\\n' +\n      'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString +\n      '\\r\\n--' + boundary + '\\r\\n' +\n      'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n  let postBlobPart = '\\r\\n--' + boundary + '--';\n  let body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  let urlParams = {'name': metadata['fullPath']};\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(\n      url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nexport class ResumableUploadStatus {\n  finalized: boolean;\n  metadata: Metadata|null;\n\n  constructor(\n      public current: number,\n      public total: number,\n      finalized?: boolean,\n      metadata?: Metadata|null) {\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n}\n\nexport function checkResumeHeader_(xhr: XhrIo, opt_allowed?: string[]): string {\n  let status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  let allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return (status as string);\n}\n\nexport function createResumableUpload(\n    authWrapper: AuthWrapper, location: Location, mappings: MetadataUtils.Mappings,\n    blob: FbsBlob, opt_metadata?: Metadata|null): RequestInfo<string> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let urlParams = {'name': metadata['fullPath']};\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr: XhrIo, text: string): string {\n    checkResumeHeader_(xhr);\n    let url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return (url as string);\n  }\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(\n    authWrapper: AuthWrapper, location: Location, url: string,\n    blob: FbsBlob): RequestInfo<ResumableUploadStatus> {\n  let headers = {'X-Goog-Upload-Command': 'query'};\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    let status = checkResumeHeader_(xhr, ['active', 'final']);\n    let sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    let size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport const resumableUploadChunkSize: number = 256 * 1024;\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(\n    location: Location, authWrapper: AuthWrapper, url: string, blob: FbsBlob,\n    chunkSize: number, mappings: MetadataUtils.Mappings,\n    opt_status?: ResumableUploadStatus|null,\n    opt_progressCallback?: ((p1: number, p2: number) => void) | null): RequestInfo<ResumableUploadStatus> {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  let status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  let bytesLeft = status.total - status.current;\n  let bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  let startByte = status.current;\n  let endByte = startByte + bytesToUpload;\n  let uploadCommand =\n      bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  let headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  let body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    let uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    let newCurrent = status.current + bytesToUpload;\n    let size = blob.size();\n    let metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(\n        newCurrent, size, uploadStatus === 'final', metadata);\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n"]}