{"version":3,"sources":["src/messaging/controllers/controller-interface.ts"],"names":["SENDER_ID_OPTION_NAME","ControllerInterface","app","errorFactory_","map","options","create","codes","BAD_SENDER_ID","messagingSenderId_","tokenManager_","INTERNAL","delete","currentPermission","getNotificationPermission_","granted","denied","Promise","reject","NOTIFICATIONS_BLOCKED","resolve","getSWRegistration_","then","getSavedToken","registration","token","createToken","deleteToken","pushManager","getSubscription","subscription","unsubscribe","SHOULD_BE_INHERITED","AVAILABLE_IN_WINDOW","AVAILABLE_IN_SW","closeDatabase","Notification","permission"],"mappings":"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","file":"controller-interface.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport {ErrorFactory} from '../../app/errors';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\n\nconst SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nexport default class ControllerInterface {\n\n  public app;\n  public INTERNAL;\n  protected errorFactory_;\n  private messagingSenderId_: string;\n  private tokenManager_: TokenManager;\n\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (!app.options[SENDER_ID_OPTION_NAME] ||\n        typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n\n    this.tokenManager_ = new TokenManager();\n\n    this.app = app;\n    this.INTERNAL = {};\n    this.INTERNAL.delete = () => this.delete;\n  }\n\n  /**\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise that\n   * resolves to an FCM token.\n   */\n  getToken() {\n    // Check with permissions\n    const currentPermission = this.getNotificationPermission_();\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(\n            this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED)\n        );\n      }\n\n      // We must wait for permission to be granted\n      return Promise.resolve(null);\n    }\n\n    return this.getSWRegistration_()\n      .then(registration => {\n        return this.tokenManager_.getSavedToken(\n            this.messagingSenderId_, registration)\n              .then(token => {\n                if (token) {\n                  return token;\n                }\n\n                return this.tokenManager_.createToken(this.messagingSenderId_,\n                  registration);\n              });\n      });\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after and then\n   * unregisters the push subscription if it exists.\n   * @export\n   * @param {string} token\n   * @return {Promise<void>}\n   */\n  deleteToken(token) {\n    return this.tokenManager_.deleteToken(token)\n      .then(() => {\n        return this.getSWRegistration_()\n        .then((registration) => {\n          if (registration) {\n            return registration.pushManager.getSubscription();\n          }\n        })\n        .then(subscription => {\n          if (subscription) {\n            return subscription.unsubscribe();\n          }\n        });\n      });\n  }\n\n  getSWRegistration_(): Promise<ServiceWorkerRegistration>  {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  requestPermission() {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n  useServiceWorker(registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n  setBackgroundMessageHandler(callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  delete() {\n    this.tokenManager_.closeDatabase();\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n  getNotificationPermission_() {\n    return (Notification as any).permission;\n  }\n\n  /**\n   * @protected\n   * @returns {TokenManager}\n   */\n  getTokenManager() {\n    return this.tokenManager_;\n  }\n}\n"]}