"use strict";
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const polymer_analyzer_1 = require("polymer-analyzer");
const stream_1 = require("stream");
const File = require("vinyl");
const path_transformers_1 = require("./path-transformers");
const file_map_url_loader_1 = require("./file-map-url-loader");
/**
 * A mapping of file extensions and their default resource type.
 */
const extensionToTypeMapping = new Map([
    ['.css', 'style'],
    ['.gif', 'image'],
    ['.html', 'document'],
    ['.png', 'image'],
    ['.jpg', 'image'],
    ['.js', 'script'],
    ['.json', 'script'],
    ['.svg', 'image'],
    ['.webp', 'image'],
    ['.woff', 'font'],
    ['.woff2', 'font'],
]);
/**
 * Get the default resource type for a file based on its extension.
 */
function getResourceTypeFromUrl(url) {
    return extensionToTypeMapping.get(path.extname(url));
}
/**
 * Get the resource type for an import, handling special import types and
 * falling back to getResourceTypeFromUrl() if the resource type can't be
 * detected directly from importFeature.
 */
function getResourceTypeFromImport(importFeature) {
    const importKinds = importFeature.kinds;
    if (importKinds.has('css-import') || importKinds.has('html-style')) {
        return 'style';
    }
    if (importKinds.has('html-import')) {
        return 'document';
    }
    if (importKinds.has('html-script')) {
        return 'script';
    }
    // @NOTE(fks) 04-07-2017: A js-import can actually import multiple types of
    // resources, so we can't guarentee that it's a script and should instead rely
    // on the default file-extension mapping.
    return getResourceTypeFromUrl(importFeature.url);
}
;
/**
 * Create a PushManifestEntry from an analyzer Import.
 */
function createPushEntryFromImport(importFeature) {
    return {
        type: getResourceTypeFromImport(importFeature),
        weight: 1,
    };
}
/**
 * Analyze the given URL and resolve with a collection of push manifest entries
 * to be added to the overall push manifest.
 */
function generatePushManifestEntryForUrl(analyzer, url, ignoreUrls) {
    return __awaiter(this, void 0, void 0, function* () {
        const analysis = yield analyzer.analyze([url]);
        const analyzedDocument = analysis.getDocument(url);
        if (!(analyzedDocument instanceof polymer_analyzer_1.Document)) {
            const message = analyzedDocument && analyzedDocument.message || 'unknown';
            throw new Error(`Unable to get document ${url}: ${message}`);
        }
        const analyzedImports = analyzedDocument.getFeatures({ kind: 'import', externalPackages: true, imported: true });
        const pushManifestEntries = {};
        function shouldIgnoreFile(url) {
            return ignoreUrls && ignoreUrls.indexOf(url) > -1;
        }
        for (const analyzedImport of analyzedImports) {
            const analyzedImportUrl = analyzedImport.url;
            const analyzedImportEntry = pushManifestEntries[analyzedImportUrl];
            if (!shouldIgnoreFile(analyzedImportUrl) && !analyzedImportEntry) {
                pushManifestEntries[analyzedImportUrl] =
                    createPushEntryFromImport(analyzedImport);
            }
        }
        return pushManifestEntries;
    });
}
;
/**
 * A stream that reads in files from an application to generate an HTTP2/Push
 * manifest that gets injected into the stream.
 */
class AddPushManifest extends stream_1.Transform {
    constructor(config, filePath) {
        super({ objectMode: true });
        this.files = new Map();
        this.config = config;
        this.analyzer = new polymer_analyzer_1.Analyzer({ urlLoader: new file_map_url_loader_1.FileMapUrlLoader(this.files) });
        this.filePath =
            path.join(this.config.root, filePath || 'push-manifest.json');
    }
    _transform(file, _encoding, callback) {
        this.files.set(path_transformers_1.urlFromPath(this.config.root, file.path), file);
        callback(null, file);
    }
    _flush(done) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate a push manifest, and propagate any errors up.
            let pushManifestContents;
            try {
                const pushManifest = yield this.generatePushManifest();
                pushManifestContents = JSON.stringify(pushManifest, undefined, '  ');
            }
            catch (err) {
                done(err);
                return;
            }
            // Push the new push manifest into the stream.
            this.push(new File({
                path: this.filePath,
                contents: new Buffer(pushManifestContents),
            }));
            done();
        });
    }
    generatePushManifest() {
        return __awaiter(this, void 0, void 0, function* () {
            const pushManifest = {};
            // If an app-shell exists, use that as our main push URL because it has a
            // reliable URL. Otherwise, support the single entrypoint URL.
            const mainPushEntrypoint = this.config.shell || this.config.entrypoint;
            // Generate the dependencies to push for the shell
            const absoluteShellUrl = path_transformers_1.urlFromPath(this.config.root, mainPushEntrypoint);
            pushManifest[absoluteShellUrl] =
                yield generatePushManifestEntryForUrl(this.analyzer, absoluteShellUrl);
            const shellImportUrls = Object.keys(pushManifest[absoluteShellUrl]);
            const fragmentIgnoreUrls = [absoluteShellUrl].concat(shellImportUrls);
            // Generate the dependencies to push for each fragment.
            for (const fragment of this.config.fragments) {
                const absoluteFragmentUrl = path_transformers_1.urlFromPath(this.config.root, fragment);
                pushManifest[absoluteFragmentUrl] = yield generatePushManifestEntryForUrl(this.analyzer, absoluteFragmentUrl, fragmentIgnoreUrls);
            }
            return pushManifest;
        });
    }
}
exports.AddPushManifest = AddPushManifest;
