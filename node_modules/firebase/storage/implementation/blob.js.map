{"version":3,"sources":["src/storage/implementation/blob.ts"],"names":["fs","string","type","FbsBlob","data","opt_elideCopy","size","blobType","isNativeBlob","data_","ArrayBuffer","Uint8Array","byteLength","set","length","size_","type_","startByte","endByte","realBlob","sliced","sliceBlob","slice","buffer","var_args","isNativeBlobDefined","blobby","map","val","getBlob","apply","uint8Arrays","isString","dataFromString","RAW","finalLength","forEach","array","merged","index","i"],"mappings":"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","file":"blob.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport {StringFormat} from './string';\nimport * as type from './type';\n\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nexport class FbsBlob {\n  private data_: Blob|Uint8Array;\n  private size_: number;\n  private type_: string;\n\n  constructor(data: Blob|Uint8Array|ArrayBuffer, opt_elideCopy?: boolean) {\n    let size: number = 0;\n    let blobType: string = '';\n    if (type.isNativeBlob(data)) {\n      this.data_ = (data as Blob);\n      size = (data as Blob).size;\n      blobType = (data as Blob).type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = (data as Uint8Array);\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set((data as Uint8Array));\n      }\n      size = data.length;\n    }\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  size(): number {\n    return this.size_;\n  }\n\n  type(): string {\n    return this.type_;\n  }\n\n  slice(startByte: number, endByte: number): FbsBlob|null {\n    if (type.isNativeBlob(this.data_)) {\n      let realBlob = (this.data_ as Blob);\n      let sliced = fs.sliceBlob(realBlob, startByte, endByte);\n      if (sliced === null) {\n        return null;\n      }\n      return new FbsBlob(sliced);\n    } else {\n      let slice =\n          new Uint8Array((this.data_ as Uint8Array).buffer, startByte, endByte - startByte);\n      return new FbsBlob(slice, true);\n    }\n  }\n\n  static getBlob(...var_args: (string|FbsBlob)[]): FbsBlob|null {\n    if (type.isNativeBlobDefined()) {\n      var blobby: (Blob|Uint8Array|string)[] = var_args.map(function(val: string|FbsBlob): Blob|Uint8Array|string {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      let uint8Arrays: Uint8Array[] = var_args.map(function(val: string|FbsBlob): Uint8Array {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val as string).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return ((val as FbsBlob).data_ as Uint8Array);\n        }\n      });\n      let finalLength = 0;\n      uint8Arrays.forEach(function(array: Uint8Array): void {\n        finalLength += array.byteLength;\n      });\n      let merged = new Uint8Array(finalLength);\n      let index = 0;\n      uint8Arrays.forEach(function(array: Uint8Array) {\n        for (let i = 0; i < array.length; i++) {\n          merged[index++] = array[i];\n        }\n      });\n      return new FbsBlob(merged, true);\n    }\n  }\n\n  uploadData(): Blob|Uint8Array {\n    return this.data_;\n  }\n}\n"]}