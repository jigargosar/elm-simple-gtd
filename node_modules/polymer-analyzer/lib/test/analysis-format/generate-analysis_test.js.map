{"version":3,"sources":["test/analysis-format/generate-analysis_test.ts"],"names":[],"mappings":"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","file":"generate-analysis_test.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {assert} from 'chai';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport {Analysis} from '../../analysis-format/analysis-format';\nimport {generateAnalysis, validateAnalysis, ValidationError} from '../../analysis-format/generate-analysis';\nimport {Analyzer} from '../../core/analyzer';\nimport {Analysis as AnalysisResult} from '../../model/analysis';\nimport {FSUrlLoader} from '../../url-loader/fs-url-loader';\nimport {PackageUrlResolver} from '../../url-loader/package-url-resolver';\n\nconst onlyTests = new Set<string>([]);  // Should be empty when not debugging.\n\n// TODO(rictic): work out how we want to handle ignoring elements from other\n//     packages in the world of Document rather than Analysis.\nconst skipTests = new Set<string>(['bower_packages', 'nested-packages']);\n\n\nconst fixturesDir = path.join(__dirname, '..', 'static');\n\nsuite('generate-analysis', () => {\n\n  suite('generateAnalysisMetadata', () => {\n\n    suite('generates for Document array from fixtures', () => {\n      const basedir = path.join(fixturesDir, 'analysis');\n      const analysisFixtureDirs =\n          fs.readdirSync(basedir)\n              .map((p) => path.join(basedir, p))\n              .filter((p) => fs.statSync(p).isDirectory());\n\n      for (const analysisFixtureDir of analysisFixtureDirs) {\n        // Generate a test from the goldens found in every dir in\n        // src/test/static/analysis/\n        const testBaseName = path.basename(analysisFixtureDir);\n        const testDefiner = onlyTests.has(testBaseName) ?\n            test.only :\n            skipTests.has(testBaseName) ? test.skip : test;\n        const testName = `produces a correct analysis.json ` +\n            `for fixture dir \\`${testBaseName}\\``;\n\n        testDefiner(testName, async() => {\n          // Test body here:\n          const documents = await analyzeDir(analysisFixtureDir);\n\n          const packages = new Set<string>(mapI(\n              filterI(\n                  walkRecursively(analysisFixtureDir),\n                  (p) =>\n                      p.endsWith('bower.json') || p.endsWith('package.json')),\n              (p) => path.dirname(p)));\n          if (packages.size === 0) {\n            packages.add(analysisFixtureDir);\n          }\n          for (const packagePath of packages) {\n            const pathToGolden = path.join(packagePath || '', 'analysis.json');\n            const renormedPackagePath = packagePath ?\n                packagePath.substring(analysisFixtureDir.length + 1) :\n                packagePath;\n            const analysisWithUndefineds =\n                generateAnalysis(documents, renormedPackagePath);\n            validateAnalysis(analysisWithUndefineds);\n            const analysis = JSON.parse(JSON.stringify(analysisWithUndefineds));\n\n            const golden: Analysis =\n                JSON.parse(fs.readFileSync(pathToGolden, 'utf-8'));\n\n            try {\n              const shortPath = path.relative(fixturesDir, pathToGolden);\n              assert.deepEqual(\n                  analysis,\n                  golden,\n                  `Generated form of ${shortPath} ` +\n                      `differs from the golden at that path`);\n            } catch (e) {\n              console.log(\n                  `Expected contents of ${pathToGolden}:\\n` +\n                  `${JSON.stringify(analysis, null, 2)}`);\n              throw e;\n            }\n          }\n        });\n      }\n    });\n\n    suite('generates from package', () => {\n\n      test('does not include external features', async() => {\n        const basedir = path.resolve(fixturesDir, 'analysis/bower_packages');\n        const analyzer = new Analyzer({\n          urlLoader: new FSUrlLoader(basedir),\n          urlResolver: new PackageUrlResolver(),\n        });\n        const _package = await analyzer.analyzePackage();\n        const metadata = generateAnalysis(_package, '');\n        // The fixture only contains external elements\n        assert.isUndefined(metadata.elements);\n      });\n\n      test('includes package features', async() => {\n        const basedir = path.resolve(fixturesDir, 'analysis/simple');\n        const analyzer = new Analyzer({\n          urlLoader: new FSUrlLoader(basedir),\n          urlResolver: new PackageUrlResolver(),\n        });\n        const _package = await analyzer.analyzePackage();\n        const metadata = generateAnalysis(_package, '');\n        assert.equal(metadata.elements && metadata.elements.length, 1);\n        assert.equal(metadata.elements![0].tagname, 'simple-element');\n        assert.equal(metadata.elements![0].path, 'simple-element.html');\n      });\n\n    });\n\n  });\n\n  suite('validateAnalysis', () => {\n\n    test('throws when validating valid analysis.json', () => {\n      try {\n        validateAnalysis({} as any);\n      } catch (err) {\n        assert.instanceOf(err, ValidationError);\n        const valError: ValidationError = err;\n        assert(valError.errors.length > 0);\n        assert.include(valError.message, `requires property \"schema_version\"`);\n        return;\n      }\n      throw new Error('expected Analysis validation to fail!');\n    });\n\n    test(`doesn't throw when validating a valid analysis.json`, () => {\n      validateAnalysis({elements: [], schema_version: '1.0.0'});\n    });\n\n    test(`doesn't throw when validating a version from the future`, () => {\n      validateAnalysis(<any>{\n        elements: [],\n        schema_version: '1.0.1',\n        new_field: 'stuff here'\n      });\n    });\n\n    test(`throws when validating a bad version`, () => {\n      try {\n        validateAnalysis(<any>{\n          elements: [],\n          schema_version: '5.1.1',\n          new_field: 'stuff here'\n        });\n      } catch (e) {\n        assert.include(e.message, 'Invalid schema_version in AnalyzedPackage');\n        return;\n      }\n      throw new Error('expected Analysis validation to fail!');\n    });\n  });\n\n});\n\nfunction* filterI<T>(it: Iterable<T>, pred: (t: T) => boolean): Iterable<T> {\n  for (const inst of it) {\n    if (pred(inst)) {\n      yield inst;\n    }\n  }\n}\n\nfunction* mapI<T, U>(it: Iterable<T>, trans: (t: T) => U): Iterable<U> {\n  for (const inst of it) {\n    yield trans(inst);\n  }\n}\n\nfunction* walkRecursively(dir: string): Iterable<string> {\n  for (const filename of fs.readdirSync(dir)) {\n    const fullPath = path.join(dir, filename);\n    if (fs.statSync(fullPath).isDirectory()) {\n      for (const f of walkRecursively(fullPath)) {\n        yield f;\n      }\n    } else {\n      yield fullPath;\n    }\n  }\n}\n\nasync function analyzeDir(baseDir: string): Promise<AnalysisResult> {\n  const analyzer = new Analyzer({\n    urlLoader: new FSUrlLoader(baseDir),\n    urlResolver: new PackageUrlResolver(),\n  });\n  const allFilenames = Array.from(walkRecursively(baseDir));\n  const htmlOrJsFilenames =\n      allFilenames.filter((f) => f.endsWith('.html') || f.endsWith('.js'));\n  const filePaths =\n      htmlOrJsFilenames.map((filename) => path.relative(baseDir, filename));\n  return analyzer.analyze(filePaths);\n}\n"]}