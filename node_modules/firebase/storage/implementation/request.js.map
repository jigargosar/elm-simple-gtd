{"version":3,"sources":["src/storage/implementation/request.ts"],"names":["addAuthHeader_","addVersionHeader_","makeRequest","array","backoff","errorsExports","object","promiseimpl","type","UrlUtils","XhrIoExports","NetworkRequest","url","method","headers","body","successCodes","additionalRetryCodes","callback","errorCallback","timeout","progressCallback","pool","pendingXhr_","backoffId_","resolve_","reject_","canceled_","appDelete_","url_","method_","headers_","body_","successCodes_","slice","additionalRetryCodes_","callback_","errorCallback_","progressCallback_","timeout_","pool_","self","promise_","make","resolve","reject","start_","doTheRequest","backoffCallback","canceled","RequestEndStatus","xhr","createXhrIo","progressListener","progressEvent","loaded","total","lengthComputable","addUploadProgressListener","send","then","removeUploadProgressListener","hitServer","getErrorCode","ErrorCode","NO_ERROR","status","getStatus","isRetryStatusCode_","wasCanceled","ABORT","successCode","contains","backoffDone","requestWentThrough","wasSuccessCode","result","getResponseText","isJustDef","e","err","unknown","setServerResponseProp","appDeleted","retryLimitExceeded","start","appDelete","stop","abort","isExtraRetryCode","isRequestSpecificRetryCode","opt_canceled","authToken","length","number","firebase","SDK_VERSION","requestInfo","queryPart","makeQueryString","urlParams","clone","handler","errorHandler"],"mappings":";;;;;;;qjBAAA;;;;;;;;;;;;;;;AAgBA;;;;;;QA6OMA,c,GAAAA,c;QAMAC,iB,GAAAA,iB;QAQAC,W,GAAAA,W;;AAvPN;;IAAYC,K;;AACZ;;IAAYC,O;;AACZ;;IAAYC,a;;AAGZ;;IAAYC,M;;AACZ;;IAAYC,W;;AAEZ;;IAAYC,I;;AACZ;;IAAYC,Q;;AACZ;;IAAYC,Y;;;;;;AAuBZ;;;;IAIAC,c;AAqBE,4BACIC,GADJ,EACiBC,MADjB,EACiCC,OADjC,EAEIC,IAFJ,EAEuCC,YAFvC,EAGIC,oBAHJ,EAIIC,QAJJ,EAKIC,aALJ,EAK2FC,OAL3F,EAMIC,gBANJ,EAOIC,IAPJ,EAOmB;AAAA;;AArBX,aAAAC,WAAA,GAA0B,IAA1B;AACA,aAAAC,UAAA,GAA8B,IAA9B;AACA,aAAAC,QAAA,GAA0B,IAA1B;AACA,aAAAC,OAAA,GAAyB,IAAzB;AACA,aAAAC,SAAA,GAAqB,KAArB;AACA,aAAAC,UAAA,GAAsB,KAAtB;AAiBN,aAAKC,IAAL,GAAYjB,GAAZ;AACA,aAAKkB,OAAL,GAAejB,MAAf;AACA,aAAKkB,QAAL,GAAgBjB,OAAhB;AACA,aAAKkB,KAAL,GAAajB,IAAb;AACA,aAAKkB,aAAL,GAAqBjB,aAAakB,KAAb,EAArB;AACA,aAAKC,qBAAL,GAA6BlB,qBAAqBiB,KAArB,EAA7B;AACA,aAAKE,SAAL,GAAiBlB,QAAjB;AACA,aAAKmB,cAAL,GAAsBlB,aAAtB;AACA,aAAKmB,iBAAL,GAAyBjB,gBAAzB;AACA,aAAKkB,QAAL,GAAgBnB,OAAhB;AACA,aAAKoB,KAAL,GAAalB,IAAb;AACA,YAAImB,OAAO,IAAX;AACA,aAAKC,QAAL,GAAgBnC,YAAYoC,IAAZ,CAAiB,UAASC,OAAT,EAAkBC,MAAlB,EAAwB;AACvDJ,iBAAKhB,QAAL,GAAgBmB,OAAhB;AACAH,iBAAKf,OAAL,GAAemB,MAAf;AACAJ,iBAAKK,MAAL;AACD,SAJe,CAAhB;AAKD;AAED;;;;;;;iCAGc;AACZ,gBAAIL,OAAO,IAAX;AAEA,qBAAAM,YAAA,CACIC,eADJ,EAEIC,QAFJ,EAEqB;AACnB,oBAAIA,QAAJ,EAAc;AACZD,oCAAgB,KAAhB,EAAuB,IAAIE,gBAAJ,CAAqB,KAArB,EAA4B,IAA5B,EAAkC,IAAlC,CAAvB;AACA;AACD;AACD,oBAAIC,MAAMV,KAAKD,KAAL,CAAWY,WAAX,EAAV;AACAX,qBAAKlB,WAAL,GAAmB4B,GAAnB;AAEA,yBAAAE,gBAAA,CAA0BC,aAA1B,EAAsD;AACpD,wBAAIC,SAASD,cAAcC,MAA3B;AACA,wBAAIC,QAAQF,cAAcG,gBAAd,GAAiCH,cAAcE,KAA/C,GAAuD,CAAC,CAApE;AACA,wBAAIf,KAAKH,iBAAL,KAA2B,IAA/B,EAAqC;AACnCG,6BAAKH,iBAAL,CAAuBiB,MAAvB,EAA+BC,KAA/B;AACD;AACF;AACD,oBAAIf,KAAKH,iBAAL,KAA2B,IAA/B,EAAqC;AACnCa,wBAAIO,yBAAJ,CAA8BL,gBAA9B;AACD;AACDF,oBAAIQ,IAAJ,CAASlB,KAAKZ,IAAd,EAAoBY,KAAKX,OAAzB,EAAkCW,KAAKT,KAAvC,EAA8CS,KAAKV,QAAnD,EACK6B,IADL,CACU,UAAST,GAAT,EAAmB;AACvB,wBAAIV,KAAKH,iBAAL,KAA2B,IAA/B,EAAqC;AACnCa,4BAAIU,4BAAJ,CAAiCR,gBAAjC;AACD;AACDZ,yBAAKlB,WAAL,GAAmB,IAAnB;AACA4B,0BAAOA,GAAP;AACA,wBAAIW,YACAX,IAAIY,YAAJ,OAAuBrD,aAAasD,SAAb,CAAuBC,QADlD;AAEA,wBAAIC,SAASf,IAAIgB,SAAJ,EAAb;AACA,wBAAI,CAACL,SAAD,IAAcrB,KAAK2B,kBAAL,CAAwBF,MAAxB,CAAlB,EAAmD;AACjD,4BAAIG,cACAlB,IAAIY,YAAJ,OAAuBrD,aAAasD,SAAb,CAAuBM,KADlD;AAEAtB,wCACI,KADJ,EACW,IAAIE,gBAAJ,CAAqB,KAArB,EAA4B,IAA5B,EAAkCmB,WAAlC,CADX;AAEA;AACD;AACD,wBAAIE,cAAcpE,MAAMqE,QAAN,CAAe/B,KAAKR,aAApB,EAAmCiC,MAAnC,CAAlB;AACAlB,oCAAgB,IAAhB,EAAsB,IAAIE,gBAAJ,CAAqBqB,WAArB,EAAkCpB,GAAlC,CAAtB;AACD,iBAnBL;AAoBD;AAED;;;;AAIA,qBAAAsB,WAAA,CACIC,kBADJ,EACiCR,MADjC,EACyD;AACvD,oBAAItB,UAAUH,KAAKhB,QAAnB;AACA,oBAAIoB,SAASJ,KAAKf,OAAlB;AACA,oBAAIyB,MAAMe,OAAOf,GAAjB;AACA,oBAAIe,OAAOS,cAAX,EAA2B;AACzB,wBAAI;AACF,4BAAIC,SAASnC,KAAKL,SAAL,CAAee,GAAf,EAAoBA,IAAI0B,eAAJ,EAApB,CAAb;AACA,4BAAIrE,KAAKsE,SAAL,CAAeF,MAAf,CAAJ,EAA4B;AAC1BhC,oCAAQgC,MAAR;AACD,yBAFD,MAEO;AACLhC;AACD;AACF,qBAPD,CAOE,OAAOmC,CAAP,EAAU;AACVlC,+BAAOkC,CAAP;AACD;AACF,iBAXD,MAWO;AACL,wBAAI5B,QAAQ,IAAZ,EAAkB;AAChB,4BAAI6B,MAAM3E,cAAc4E,OAAd,EAAV;AACAD,4BAAIE,qBAAJ,CAA0B/B,IAAI0B,eAAJ,EAA1B;AACA,4BAAIpC,KAAKJ,cAAT,EAAyB;AACvBQ,mCAAOJ,KAAKJ,cAAL,CAAoBc,GAApB,EAAyB6B,GAAzB,CAAP;AACD,yBAFD,MAEO;AACLnC,mCAAOmC,GAAP;AACD;AACF,qBARD,MAQO;AACL,4BAAId,OAAOjB,QAAX,EAAqB;AACnB,gCAAI+B,OAAMvC,KAAKb,UAAL,GAAkBvB,cAAc8E,UAAd,EAAlB,GACkB9E,cAAc4C,QAAd,EAD5B;AAEAJ,mCAAOmC,IAAP;AACD,yBAJD,MAIO;AACL,gCAAIA,QAAM3E,cAAc+E,kBAAd,EAAV;AACAvC,mCAAOmC,KAAP;AACD;AACF;AACF;AACF;AACD,gBAAI,KAAKrD,SAAT,EAAoB;AAClB8C,4BAAY,KAAZ,EAAmB,IAAIvB,gBAAJ,CAAqB,KAArB,EAA4B,IAA5B,EAAkC,IAAlC,CAAnB;AACD,aAFD,MAEO;AACL,qBAAK1B,UAAL,GAAkBpB,QAAQiF,KAAR,CAActC,YAAd,EAA4B0B,WAA5B,EAAyC,KAAKlC,QAA9C,CAAlB;AACD;AACF;AAED;;;;qCACU;AACR,mBAAO,KAAKG,QAAZ;AACD;AAED;;;;+BACO4C,S,EAAmB;AACxB,iBAAK3D,SAAL,GAAiB,IAAjB;AACA,iBAAKC,UAAL,GAAkB0D,aAAa,KAA/B;AACA,gBAAI,KAAK9D,UAAL,KAAoB,IAAxB,EAA8B;AAC5BpB,wBAAQmF,IAAR,CAAa,KAAK/D,UAAlB;AACD;AACD,gBAAI,KAAKD,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,qBAAKA,WAAL,CAAiBiE,KAAjB;AACD;AACF;;;2CAE0BtB,M,EAAc;AACvC;AACA;AAQA,gBAAIuB,mBAAmBtF,MAAMqE,QAAN,CAND;AACpB;AACA,eAFoB;AAGpB;AACA,eAJoB,CAMC,EAAgCN,MAAhC,CAAvB;AACA,gBAAIwB,6BACAvF,MAAMqE,QAAN,CAAe,KAAKrC,qBAApB,EAA2C+B,MAA3C,CADJ;AAEA,mBAVwBA,UAAU,GAAV,IAAiBA,SAAS,GAU3C,IAAqBuB,gBAArB,IAAyCC,0BAAhD;AACD;;;;;AAGH;;;;;;;IAKMxC,gB,WAAAA,gB,GAMJ,0BACWyB,cADX,EAC2CxB,GAD3C,EAEIwC,YAFJ,EAE0B;AAAA;;AADf,SAAAhB,cAAA,GAAAA,cAAA;AAAgC,SAAAxB,GAAA,GAAAA,GAAA;AAEzC,SAAKF,QAAL,GAAgB,CAAC,CAAC0C,YAAlB;AACD,C;;AAGG,SAAA3F,cAAA,CAAyBc,OAAzB,EAA2C8E,SAA3C,EAAiE;AACrE,QAAIA,cAAc,IAAd,IAAsBA,UAAUC,MAAV,GAAmB,CAA7C,EAAgD;AAC9C/E,gBAAQ,eAAR,IAA2B,cAAc8E,SAAzC;AACD;AACF;AAEK,SAAA3F,iBAAA,CAA4Ba,OAA5B,EAA4C;AAChD,QAAIgF,SAAS,OAAOC,QAAP,KAAoB,WAApB,GAAkCA,SAASC,WAA3C,GAAyD,YAAtE;AACAlF,YAAQ,4BAAR,IAAwC,WAAWgF,MAAnD;AACD;AAED;;;AAGM,SAAA5F,WAAA,CACF+F,WADE,EAC2BL,SAD3B,EAEFtE,IAFE,EAEa;AACjB,QAAI4E,YAAYzF,SAAS0F,eAAT,CAAyBF,YAAYG,SAArC,CAAhB;AACA,QAAIxF,MAAMqF,YAAYrF,GAAZ,GAAkBsF,SAA5B;AACA,QAAIpF,UAAUR,OAAO+F,KAAP,CAAsBJ,YAAYnF,OAAlC,CAAd;AACAd,mBAAec,OAAf,EAAwB8E,SAAxB;AACA3F,sBAAkBa,OAAlB;AACA,WAAO,IAAIH,cAAJ,CACHC,GADG,EACEqF,YAAYpF,MADd,EACsBC,OADtB,EAC+BmF,YAAYlF,IAD3C,EAEHkF,YAAYjF,YAFT,EAEuBiF,YAAYhF,oBAFnC,EAGHgF,YAAYK,OAHT,EAGkBL,YAAYM,YAH9B,EAG4CN,YAAY7E,OAHxD,EAIH6E,YAAY5E,gBAJT,EAI2BC,IAJ3B,CAAP;AAKD","file":"request.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport {FirebaseStorageError} from './error';\nimport {errors} from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport {RequestInfo} from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport {Headers, XhrIo} from './xhrio';\nimport {XhrIoPool} from './xhriopool';\nimport { FirebaseNamespace } from \"../../app/firebase_app\";\n\ndeclare var firebase: FirebaseNamespace;\n\n/**\n * @template T\n */\nexport interface Request<T> {\n  getPromise(): Promise<T>;\n\n  /**\n   * Cancels the request. IMPORTANT: the promise may still be resolved with an\n   * appropriate value (if the request is finished before you call this method,\n   * but the promise has not yet been resolved), so don't just assume it will be\n   * rejected if you call this function.\n   * @param appDelete True if the cancelation came from the app being deleted.\n   */\n  cancel(appDelete?: boolean): void;\n}\n\n/**\n * @struct\n * @template T\n */\nclass NetworkRequest<T> implements Request<T> {\n  private url_: string;\n  private method_: string;\n  private headers_: Headers;\n  private body_: string|Blob|Uint8Array|null;\n  private successCodes_: number[];\n  private additionalRetryCodes_: number[];\n  private pendingXhr_: XhrIo|null = null;\n  private backoffId_: backoff.id|null = null;\n  private resolve_: Function|null = null;\n  private reject_: Function|null = null;\n  private canceled_: boolean = false;\n  private appDelete_: boolean = false;\n  private callback_: (p1: XhrIo, p2: string) => T;\n  private errorCallback_: ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError) | null;\n  private progressCallback_:\n      ((p1: number, p2: number) => void) | null;\n  private timeout_: number;\n  private pool_: XhrIoPool;\n  promise_: Promise<T>;\n\n  constructor(\n      url: string, method: string, headers: Headers,\n      body: string|Blob|Uint8Array|null, successCodes: number[],\n      additionalRetryCodes: number[],\n      callback: (p1: XhrIo, p2: string) => T,\n      errorCallback: ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError) | null, timeout: number,\n      progressCallback: ((p1: number, p2: number) => void) | null,\n      pool: XhrIoPool) {\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    let self = this;\n    this.promise_ = promiseimpl.make(function(resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n\n  /**\n   * Actually starts the retry loop.\n   */\n  private start_() {\n    let self = this;\n\n    function doTheRequest(\n        backoffCallback: (p1: boolean, ...p2: any[]) => void,\n        canceled: boolean) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      let xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent: ProgressEvent) {\n        let loaded = progressEvent.loaded;\n        let total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr.send(self.url_, self.method_, self.body_, self.headers_)\n          .then(function(xhr: XhrIo) {\n            if (self.progressCallback_ !== null) {\n              xhr.removeUploadProgressListener(progressListener);\n            }\n            self.pendingXhr_ = null;\n            xhr = (xhr as XhrIo);\n            let hitServer =\n                xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n            let status = xhr.getStatus();\n            if (!hitServer || self.isRetryStatusCode_(status)) {\n              let wasCanceled =\n                  xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n              backoffCallback(\n                  false, new RequestEndStatus(false, null, wasCanceled));\n              return;\n            }\n            let successCode = array.contains(self.successCodes_, status);\n            backoffCallback(true, new RequestEndStatus(successCode, xhr));\n          });\n    }\n\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(\n        requestWentThrough: boolean, status: RequestEndStatus) {\n      let resolve = self.resolve_ as Function;\n      let reject = self.reject_ as Function;\n      let xhr = status.xhr as XhrIo;\n      if (status.wasSuccessCode) {\n        try {\n          let result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          let err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            let err = self.appDelete_ ? errorsExports.appDeleted() :\n                                        errorsExports.canceled();\n            reject(err);\n          } else {\n            let err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  }\n\n  /** @inheritDoc */\n  getPromise() {\n    return this.promise_;\n  }\n\n  /** @inheritDoc */\n  cancel(appDelete?: boolean) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  }\n\n  private isRetryStatusCode_(status: number): boolean {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    let isFiveHundredCode = status >= 500 && status < 600;\n    let extraRetryCodes = [\n      // Request Timeout: web server didn't receive full request in time.\n      408,\n      // Too Many Requests: you're getting rate-limited, basically.\n      429\n    ];\n    let isExtraRetryCode = array.contains(extraRetryCodes, status);\n    let isRequestSpecificRetryCode =\n        array.contains(this.additionalRetryCodes_, status);\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  }\n}\n\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nexport class RequestEndStatus {\n  /**\n   * True if the request was canceled.\n   */\n  canceled: boolean;\n\n  constructor(\n      public wasSuccessCode: boolean, public xhr: XhrIo|null,\n      opt_canceled?: boolean) {\n    this.canceled = !!opt_canceled;\n  }\n}\n\nexport function addAuthHeader_(headers: Headers, authToken: string|null) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\n\nexport function addVersionHeader_(headers: Headers) {\n  let number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n\n/**\n * @template T\n */\nexport function makeRequest<T>(\n    requestInfo: RequestInfo<T>, authToken: string|null,\n    pool: XhrIoPool): Request<T> {\n  let queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  let url = requestInfo.url + queryPart;\n  let headers = object.clone<Headers>(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest<T>(\n      url, requestInfo.method, headers, requestInfo.body,\n      requestInfo.successCodes, requestInfo.additionalRetryCodes,\n      requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout,\n      requestInfo.progressCallback, pool);\n}\n"]}